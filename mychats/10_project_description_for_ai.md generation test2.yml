- role: system
  content: |-
    You are to generate a `project_description_for_ai.md` file that fully describes the project, with the goal of enabling an AI agent to confidently understand, modify, and extend any part of the project.
    Begin by requesting the project directory tree from the user.
    Systematically identify which files, scripts, or resources are necessary for a complete understanding of the project structure, logic, and extensibility. Request these files from the user as needed.
    Carefully review the files provided. If additional information or files are required to ensure the AI agent can perform safe and effective modifications, request them from the user.
    After gathering enough context, produce a `project_description_for_ai.md` file containing the following sections, each written with a focus on making future modifications and extensions as straightforward as possible for an AI agent:
    # Steps
    1. **Request Project Directory Tree**: Ask the user to provide the project’s directory structure.
    2. **Identify Key Files for Modification**: Determine which files and resources are most important for understanding and changing project behavior or structure, and request them from the user.
    3. **Review and Request Supplementary Files**: Analyze provided files for completeness and request further files as necessary for modification tasks.
    4. **Compile Modification-Focused Documentation**: Collate all information required for an AI agent to make any changes or extensions.
    5. **Generate `project_description_for_ai.md`**: Write the markdown file, structured as described.
    # Output Format
    Your output should be a markdown file named `project_description_for_ai.md`, organized as follows:
    1. **Project Overview**: Concise explanation of the project’s purpose and main features.
    2. **Project Directory Tree**: The root-to-leaf structure of files and folders.
    3. **File-by-File Explanation**: Detailed descriptions of each significant file, focusing on their function, how they work together, and which parts are most relevant for modification.
    4. **Important Design Notes for Modification**: Explain architectural decisions, extensibility points, and where/how changes should be made for different types of modifications.
    5. **Security Considerations**: Outline current security practices and highlight any areas where modifications could introduce vulnerabilities.
    6. **Summary Table of Extensible Components**: Table listing primary files, modules, or locations in the codebase that are important for extending or modifying the project, with a brief on what can safely be changed.
    7. **Final Notes**: Supplementary thoughts, development conventions, or anything critical for an AI agent to know before making changes.
    # Guidance
    - Write all instructions and descriptions with the explicit goal of enabling a non-human agent to safely and effectively modify, extend, or refactor the project.
    - Use technical language aligned with the project’s domain or stack.
    - Highlight interfaces, APIs, configuration files, or extension points that are relevant for programmatic modification.
    - Explicitly address potential risks or architectural pitfalls that an agent should consider when making changes.
    - Ensure documentation is comprehensive and actionable for an AI agent with no prior context of the project.
  selected: true
- role: user
  content: |-
    This is the tree
    ```ini
    .
    ├── CHANGELOG.md
    ├── current_settings
    │   ├── prompts.json
    │   └── providers.json
    ├── diegoaacchatgpt-1.1.0.vsix
    ├── dist
    │   ├── extension.js
    │   ├── extension.js.LICENSE.txt
    │   └── extension.js.map
    ├── examples
    │   ├── create.png
    │   ├── explain.png
    │   ├── main.png
    │   └── refactor.png
    ├── media
    │   ├── main.js
    │   ├── scripts
    │   │   ├── microlight.min.js
    │   │   ├── showdown.min.js
    │   │   └── tailwind.min.js
    │   └── styles.css
    ├── package-lock.json
    ├── package.json
    ├── README.md
    ├── resources
    │   ├── buy-default-yellow-small.png
    │   ├── extensionIcon.png
    │   └── icon.png
    ├── src
    │   ├── chatGptViewProvider.ts
    │   ├── extension.ts
    │   └── types.ts
    ├── toGenerateXSIX.txt
    ├── tsconfig.json
    ├── vsc-extension-quickstart.md
    ├── webpack.config.js
    └── yarn.lock
    ```
  selected: true
- role: assistant
  content: |-
    Thank you for providing the directory tree.

    To accurately document the project for safe and effective modification/extension, I need to identify the core files that define behavior, configuration, and extension points. Here are follow-up questions and requests:

    ## 1. Primary Source Files
    Please provide the contents or code for the following files in the `src` directory, as they are likely the main entry points and contain most of the functional logic:
    - `src/extension.ts`
    - `src/chatGptViewProvider.ts`
    - `src/types.ts`

    ## 2. Configuration and Manifest Files
    Please provide the contents of these files, which likely define extension points, dependencies, activation events, and build/transpile steps:
    - `package.json`
    - `tsconfig.json`
    - `webpack.config.js`

    ## 3. Settings and Configuration
    Please provide the structure and example contents (you may redact sensitive info) of the files in:
    - `current_settings/prompts.json`
    - `current_settings/providers.json`

    ## 4. If time permits
    If there are custom scripts or logic present in:
    - `media/main.js`
    - `media/styles.css`
    Please provide those files if they are used for webview or user interfaces and are not merely standard libraries.

    ---
    Once you've provided these files and details, I will review and let you know if further information is required. This will enable me to generate a precise and actionable `project_description_for_ai.md`.
  selected: true
- role: user
  content: "**src/chatGptViewProvider.ts**\n```ts\nimport * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport * as yaml from 'js-yaml';\nimport OpenAI from \"openai\";\nimport { encodingForModel } from \"js-tiktoken\";\nimport { AuthInfo, Settings, Message, Provider, Prompt, UserMessage, BASE_URL } from './types';\nimport { ChatCompletionContentPart, ChatCompletionContentPartImage, ChatCompletionContentPartText } from 'openai/resources/chat/completions';\n\nexport class ChatGPTViewProvider implements vscode.WebviewViewProvider {\n  public static readonly viewType = 'chatgpt.chatView';\n  private _view?: vscode.WebviewView;\n\n  private _conversation?: any;\n  private _messages?: Message[];\n  private _openai?: OpenAI;\n\n  private _response?: string;\n  private _totalNumberOfTokens?: number;\n  private _prompt?: string;\n  private _fullPrompt?: string;\n  private _currentMessageNumber = 0;\n  private _enc = encodingForModel(\"gpt-4\"); //Hardcoded for now\n\n  private _settings: Settings = {\n    selectedInsideCodeblock: false,\n    codeblockWithLanguageId: false,\n    pasteOnClick: true,\n    keepConversation: true,\n    timeoutLength: 60,\n    apiUrl: BASE_URL,\n    model: 'gpt-3.5-turbo',\n    options: {\n    },\n  };\n  private _authInfo?: AuthInfo;\n\n  // In the constructor, we store the URI of the extension\n  constructor(private readonly _extensionUri: vscode.Uri) {\n    this._messages = [];\n    this._messages?.push({ role: \"system\", content: this.getStartSystemPrompt(), selected:true });\n    console.log(\"constructor....\");\n    console.log(\"messages:\", this._messages);\n  }\n\n  // Set the API key and create a new API instance based on this key\n  public setAuthenticationInfo(authInfo: AuthInfo) {\n    this._authInfo = authInfo;\n    this._newAPI();\n  }\n\n  public setSettings(settings: Settings) {\n    let changeModel = false;\n  \n    // Check if there are any keys in the options object of the settings\n    if (settings.apiUrl || settings.model || (settings.options && Object.keys(settings.options).length > 0)) {\n      changeModel = true;\n    }\n  \n    // Update settings with the new values\n    this._settings = { ...this._settings, ...settings };\n  \n    if (changeModel) {\n      //this._newAPI();\n    }\n  }\n\n  public getSettings() {\n    return this._settings;\n  }\n\n  // This private method initializes a new ChatGPTAPI instance\n  private _newAPI() {\n    console.log(\"New API\");\n    console.log(\"Messages:\", this._messages);\n    if (!this._authInfo || !this._settings?.apiUrl) {\n      console.warn(\"API key or API URL not set, please go to extension settings (read README.md for more info)\");\n    } else {\n      console.log(\"apiUrl:\", this._settings?.apiUrl);\n      this._openai = new OpenAI(\n        {\n          apiKey: this._authInfo?.apiKey,\n          baseURL: this._authInfo?.apiUrl\n        }\n      );\n    }\n    setTimeout(() => {\n      const chat_response = this._updateChatMessages(\n        this._getMessagesNumberOfTokens(),\n        0\n      );\n      this._view?.webview.postMessage({ type: 'addResponse', value: chat_response });\n    }, 2000);\n  }\n\n  public resolveWebviewView(\n    webviewView: vscode.WebviewView,\n    context: vscode.WebviewViewResolveContext,\n    _token: vscode.CancellationToken,\n  ) {\n    this._view = webviewView;\n\n    // set options for the webview, allow scripts\n    webviewView.webview.options = {\n      enableScripts: true,\n      localResourceRoots: [\n        this._extensionUri\n      ]\n    };\n\n    // set the HTML for the webview\n    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);\n\n    // add an event listener for messages received by the webview\n    webviewView.webview.onDidReceiveMessage(async data =>  {\n      switch (data.type) {\n        case 'ready':\n          {\n            const config = vscode.workspace.getConfiguration('chatgpt');\n            let providers: Provider[] = config.get('providers') || [];\n            let prompts: Prompt[] = config.get('prompts') || [];\n            this.set_providers(providers);\n            this.set_prompts(prompts);\n            break;\n          }\n        case 'codeSelected':\n          {\n            // do nothing if the pasteOnClick option is disabled\n            if (!this._settings.pasteOnClick) {\n              break;\n            }\n            let code = data.value;\n            const snippet = new vscode.SnippetString();\n            snippet.appendText(code);\n            // insert the code as a snippet into the active text editor\n            vscode.window.activeTextEditor?.insertSnippet(snippet);\n            break;\n          }\n        case 'pasteImage': \n          {\n            const base64Data = data.value;\n            const imageType = base64Data.substring(base64Data.indexOf(':') + 1, base64Data.indexOf(';'));\n            const fileType = imageType.split('/')[1];\n            const fileName = `clipboard_image.${fileType}`;\n            this.addImageToChat(base64Data, fileName);\n            break;\n          }\n        case 'prompt':\n          {\n            console.log(\"prompt\");\n            this.search(data.value);\n            break;\n          }\n        case 'promptNoQuery':\n          {\n            console.log(\"promptNoQuery\");\n\n            let searchPrompt = await this._generate_search_prompt(data.value);\n            \n            this._messages?.push({ role: \"user\", content: searchPrompt, selected:true })\n            let chat_response = this._updateChatMessages(\n              this._getMessagesNumberOfTokens(),\n              0\n            );\n            this._response = chat_response;\n            this._view?.webview.postMessage({ type: 'addResponse', value: chat_response });\n            break;\n          }\n        case 'checkboxChanged':\n          {\n            console.log(\"checkboxChanged:\", data);\n            const idParts = data.id.split('-'); // Split the id into parts\n            if(idParts.length === 3) {\n              const indexStr = idParts[2]; // Grab the last part, which should contain the index\n              const index = parseInt(indexStr, 10); // Convert the index to an integer and adjust if necessary\n            \n              if(this._messages && index >= 0 && index < this._messages.length) {\n                // If the index is within the bounds of the array, update the checked status\n                this._messages[index].selected = data.checked;\n              } else {\n                // Handle cases where index is out of bounds or _messages is not an array\n                console.error('Index is out of bounds or _messages is not properly defined.');\n              }\n            } else {\n              // Handle cases where data.id does not follow the expected format\n              console.error('data.id is not in the expected format.');\n            }\n            break;\n          }\n        case 'messageContentChanged':\n          {\n            console.log(\"messageContentChanged:\", data);\n            const idParts = data.id.split('-'); // Split the id into parts\n            if(idParts.length === 3) {\n              const indexStr = idParts[2]; // Grab the last part, which should contain the index\n              const index = parseInt(indexStr, 10); // Convert the index to an integer and adjust if necessary\n            \n              if(this._messages && index >= 0 && index < this._messages.length) {\n                // If the index is within the bounds of the array, update the checked status\n                this._messages[index].content = data.value;\n              } else {\n                // Handle cases where index is out of bounds or _messages is not an array\n                console.error('Index is out of bounds or _messages is not properly defined.');\n              }\n            } else {\n              // Handle cases where data.id does not follow the expected format\n              console.error('data.id is not in the expected format.');\n            }\n            console.log(\"messages:\", this._messages);\n            break;\n          }\n        case \"providerModelChanged\":\n          {\n            const providerIndex = data.providerIndex;\n            const modelIndex = data.modelIndex;\n            console.log(\"Provider Changed, providerIndex:\", providerIndex, \", model:\", modelIndex);\n\n            const config = vscode.workspace.getConfiguration('chatgpt');\n            let providers: Provider[] = config.get('providers') || [];\n      \n            if (providers && providers.length > providerIndex) {\n              const provider_data = providers[providerIndex];\n              if (provider_data.models && provider_data.models.length > modelIndex) {\n                const model_data = provider_data.models[modelIndex];\n                const provider_settings = {\n                  model: model_data.name,\n                  apiUrl: provider_data.apiUrl,\n                  apiKey: provider_data.apiKey,\n                  options: {\n                  ...model_data.options // assuming model_data contains options and it includes maxModelTokens, maxResponseTokens, and temperature\n                  },\n                };\n                this.setSettings({\n                  apiUrl: provider_settings.apiUrl,\n                  model: provider_settings.model,\n                  options: {\n                  ...provider_settings.options, // Spread operator to include all keys from options\n                  },\n                });\n                // Put configuration settings into the provider\n                this.setAuthenticationInfo({\n                  apiKey: provider_settings.apiKey,\n                  apiUrl: provider_settings.apiUrl\n                });\n              }\t\t\t\t\t\t\n            }\n            break;\n          }\n        case \"systemPromptChanged\":\n          {\n            const systemPromptIndex = data.systemPromptIndex;\n            console.log(\"systemPrompt Changed, providerIndex:\", systemPromptIndex);\n\n            const config = vscode.workspace.getConfiguration('chatgpt');\n            let prompts: Prompt[] = config.get('prompts') || [];\n      \n            if (prompts && prompts.length > systemPromptIndex) {\n              const prompt_data = prompts[systemPromptIndex];\n              if (prompt_data.name && prompt_data.prompt) {\n                this.set_prompt(prompt_data);\n              }\t\t\t\t\t\t\n            }\n            break;\n          }\n      }\n    });\n  }\n\n  public getStartSystemPrompt() {\n    const config = vscode.workspace.getConfiguration('chatgpt');\n    let prompts: Prompt[] = config.get('prompts') || [];\n    let start_system_prompt = \"You are a helpful assistant.\";\n    if (prompts && prompts.length > 0) {\n      const prompt_data = prompts[0];\n      if (prompt_data.name && prompt_data.prompt) {\n        start_system_prompt = prompt_data.prompt;\n      }\t\t\t\t\t\t\n    }\n    return start_system_prompt;\n  }\n\n\n  public async resetConversation() {\n    console.log(this, this._conversation);\n    if (this._conversation) {\n      this._conversation = null;\n    }\n    this._prompt = '';\n    this._response = '';\n    this._fullPrompt = '';\n    this._totalNumberOfTokens = 0;\n    this._view?.webview.postMessage({ type: 'setPrompt', value: '' });\n    this._messages = [];\n    \n    this._messages?.push({ role: \"system\", content: this.getStartSystemPrompt(), selected:true });\n    const chat_response = this._updateChatMessages(\n      this._getMessagesNumberOfTokens(),\n      0\n    );\n    this._view?.webview.postMessage({ type: 'addResponse', value: chat_response });\n  }\n\n  public async pasteChat() {\n    console.log(\"pasteChat\");\n  \n    // Ensure there is an active text editor where we can paste the YAML\n    if (!vscode.window.activeTextEditor) {\n      vscode.window.showErrorMessage('No active text editor!');\n      return;\n    }\n  \n    try {\n      // Get the original _messages object\n      // If you want to exclude any other properties from the YAML, you can map and remove them here\n      const messagesForYaml = this._messages?.map(({ role, content, selected }) => ({\n        role, content, selected\n      }));\n  \n      // Convert messages to a YAML string\n      const messagesYaml = yaml.dump(messagesForYaml, { noRefs: true, lineWidth: -1 });\n  \n      // Create a new snippet and append the YAML string\n      const snippet = new vscode.SnippetString();\n      snippet.appendText(messagesYaml);\n  \n      // Insert the snippet into the active text editor\n      await vscode.window.activeTextEditor.insertSnippet(snippet);\n  \n      console.log(\"Chat pasted as YAML successfully.\");\n    } catch (error) {\n      console.error(\"Failed to paste chat as YAML:\", error);\n      vscode.window.showErrorMessage('Failed to paste chat as YAML: ' + error);\n    }\n  }\n  \n  public async useSelectionAsChat() {\n    console.log(\"use selection as chat\");\n\n    // Ensure there is an active text editor with a selection\n    const activeEditor = vscode.window.activeTextEditor;\n    if (!activeEditor) {\n      vscode.window.showErrorMessage('No active text editor with a selection!');\n      return;\n    }\n\n    const selection = activeEditor.selection;\n    if (selection.isEmpty) {\n      vscode.window.showErrorMessage('No text selected!');\n      return;\n    }\n\n    // Get the selected text\n    const selectedText = activeEditor.document.getText(selection);\n\n    try {\n      // Parse the selected text as YAML\n      const parsedMessages = yaml.load(selectedText);\n\n      // Validate the parsed YAML structure\n      if (!Array.isArray(parsedMessages)) {\n        throw new Error('Selected text is not an array of messages.');\n      }\n\n      // Validation of each message in the array\n      for (const msg of parsedMessages) {\n        if (typeof msg !== 'object' || !('role' in msg) || !('content' in msg) || !('selected' in msg)) {\n          throw new Error('Invalid message format. Each message must have role, content, and selected properties.');\n        }\n      }\n\n      // If valid, update the _messages array with new data\n      this._messages = parsedMessages;\n\n      // Update the webview visualization\n      const chat_response = this._updateChatMessages(\n        this._getMessagesNumberOfTokens(),\n        0\n      );\n      this._view?.webview.postMessage({ type: 'addResponse', value: chat_response });\n\n      console.log(\"Updated messages from selection successfully.\");\n    } catch (error) {\n      console.error(\"Failed to use selection as chat:\", error);\n      vscode.window.showErrorMessage('Failed to use selection as chat: ' + error);\n    }\n  }\n\n  public fixCodeBlocks(response: string) {\n    // Use a regular expression to find all occurrences of the substring in the string\n    const REGEX_CODEBLOCK = new RegExp('\\`\\`\\`', 'g');\n    const matches = response.match(REGEX_CODEBLOCK);\n\n    // Return the number of occurrences of the substring in the response, check if even\n    const count = matches ? matches.length : 0;\n    if (count % 2 === 0) {\n      return response;\n    } else {\n      // else append ``` to the end to make the last code block complete\n      console.log(\"Warning - code block not complete\");\n      return response.concat('\\n\\`\\`\\`');\n    }\n\n  }\n\n  private _getMessagesNumberOfTokens() {\n    \n    let full_promt = \"\";\n    if (this._messages) {\n      for (const message of this._messages) {\n        if (message.selected) {\n          full_promt += \"\\n# <u>\" + message.role.toUpperCase() + \"</u>:\\n\" + message.content;\n        }\n      }\n    }\n\n    const tokenList = this._enc.encode(full_promt);\n    return tokenList.length;\n  }\n\n\n  \n  public getSelectedMessagesWithoutSelectedProperty(): Omit<Message, 'selected'>[] {\n    let ret = this._messages?.filter(message => message.selected).map(({ role, content }) => ({\n    role, content\n    })) || [];\n    return ret;\n  }\n\n  private _containsCodeBlockOrListItems(content: string): boolean {\n    // Regex pattern to match code blocks.\n    const codeBlockPattern = /```[\\s\\S]*?```/;\n  \n    // Regex pattern to match bullet points or numbered list items.\n    const listItemPattern = /^(?:\\s*(?:[-*+]|\\d+\\.)\\s+.+)$/m;\n  \n    // Test if the content contains a code block or list items.\n    return codeBlockPattern.test(content) || listItemPattern.test(content);\n  }\n\n\n  private isChatCompletionContentPart(value: any): value is ChatCompletionContentPart {\n    return this.isChatCompletionContentPartImage(value);\n  }\n  \n    \n  private isChatCompletionContentPartText(value: any): value is ChatCompletionContentPartText {\n    return typeof value === 'object'\n      && value != null\n      && typeof value.text === 'string'\n      && value.type === 'text';\n  }\n  private isChatCompletionContentPartImage(value: any): value is ChatCompletionContentPartImage {\n    return typeof value === 'object'\n      && value !== null\n      && typeof value.image_url === 'object'\n      && typeof value.image_url.url === 'string'\n      && value.type === 'image_url';\n  }\n    \n  private _updateChatMessages(promtNumberOfTokens:number, completionTokens:number) {\n    let chat_response = \"\";\n    if (this._messages) {\n      this._messages.forEach((message, index) => {\n        const selected = message.selected;\n        const checked_string = selected ? \"checked\" : \"\";\n        if (typeof message.content === 'string') {\n          if (this._containsCodeBlockOrListItems(message.content)) {\n            chat_response += \"\\n# <u> <input id='message-checkbox-\" + index + \"' type='checkbox' \" + checked_string + \" onchange='myFunction(this)'> \" + message.role.toUpperCase() + \"</u>:\\n\" + message.content;\n          } else {\n            chat_response += \"\\n# <u> <input id='message-checkbox-\" + index + \"' type='checkbox' \" + checked_string + \" onchange='myFunction(this)'> \" + message.role.toUpperCase() + \"</u>: <div id='message-content-\" + index + \"' contenteditable='false' onclick='makeEditable(this)' onblur='saveContent(this)'>\"+ message.content + \"</div>\";\n          }\n        } else if (Array.isArray(message.content)) {\n          // Handle the case where message.content is an array of ChatCompletionContentPartImage\n          chat_response += \"\\n# <u> <input id='message-checkbox-\" + index + \"' type='checkbox' \" + checked_string + \" onchange='myFunction(this)'> \" + message.role.toUpperCase() + \"</u>: <div id='message-content-\" + index + \"' contenteditable='false'>\";\n          message.content.forEach(part => {\n            console.log(\"processing an object...\")\n            if (this.isChatCompletionContentPartImage(part)) {\n              console.log(\"Is an image!!!\")\n              // Process each ChatCompletionContentPartImage item\n              chat_response += \"<img src='\"+ part.image_url.url + \"' alt='Base64 Image'/>\";\n            }\n            if (this.isChatCompletionContentPartText(part)) {\n              console.log(\"Is a text!!!\")\n              chat_response += part.text;\n            }\n          });\n          chat_response += \"</div>\"\n        }\n      });\n    }\n    if (this._totalNumberOfTokens !== undefined) {\n      this._totalNumberOfTokens += promtNumberOfTokens + completionTokens;\n      chat_response += `\\n\\n---\\n*<sub>Total Tokens: ${this._totalNumberOfTokens},  Tokens used: ${promtNumberOfTokens + completionTokens} (${promtNumberOfTokens}+${completionTokens}), model: ${this._settings.model}</sub>* \\n\\n---\\n\\n\\n\\n\\n\\n\\n`;\n    }\n    return chat_response;\n  }\n  \n  private async _generate_search_prompt(prompt:string) {\n    this._prompt = prompt;\n    if (!prompt) {\n      prompt = '';\n    }\n\n    // Focus the ChatGPT view\n    if (!this._view) {\n      await vscode.commands.executeCommand('chatgpt.chatView.focus');\n    } else {\n      this._view?.show?.(true);\n    }\n\n    // Initialize response and token count\n    \n    if (!this._response) {\n      this._response = '';\n    }\n    if (!this._totalNumberOfTokens) {\n      this._totalNumberOfTokens = 0;\n    }\n\n    // Get selected text and language ID (if applicable)\n    const selection = vscode.window.activeTextEditor?.selection;\n    const selectedText = vscode.window.activeTextEditor?.document.getText(selection);\n    const languageId =\n      (this._settings.codeblockWithLanguageId\n        ? vscode.window.activeTextEditor?.document?.languageId\n        : undefined) || '';\n\n    // Build the search prompt\n    let searchPrompt = '';\n    if (selection && selectedText) {\n      if (this._settings.selectedInsideCodeblock) {\n        searchPrompt = `${prompt}\\n\\`\\`\\`${languageId}\\n${selectedText}\\n\\`\\`\\``;\n      } else {\n        searchPrompt = `${prompt}\\n${selectedText}\\n`;\n      }\n    } else {\n      searchPrompt = prompt;\n    }\n    this._fullPrompt = searchPrompt;\n\n    // Increment message number and store for tracking\n    this._currentMessageNumber++;\n    return searchPrompt;\n\n  }\n\n  public set_providers(providers: Provider[]): void {\n    this._view?.webview.postMessage({ type: 'initialize', value: providers });\n  }\n\n  public set_prompts(prompts: Prompt[]): void {\n    console.log(\"Set Prompts:\", prompts);\n    this._view?.webview.postMessage({ type: 'initialize_prompts', value: prompts });\n  }\n\n  public set_prompt(prompt: Prompt): void {\n    // Check if _messages is defined\n    if (this._messages) {\n      this._messages[0] = { role: \"system\", content: prompt.prompt, selected: true };\n    } else {\n      this._messages = [{ role: \"system\", content: prompt.prompt, selected: true }];\n    }\n    console.log(\"calling updateResponse\");\n    let chat_response = this._updateChatMessages(0, 0)\n\n    this._view?.webview.postMessage({ type: 'addResponse', value: chat_response });\n    this._view?.webview.postMessage({ type: 'setPrompt', value: '' });\n  }\n\n  public async search(prompt?: string) {\n    // Check if the API key and URL are set\n    if (!this._authInfo || !this._settings?.apiUrl) {\n      this._view?.webview.postMessage({\n        type: 'addResponse',\n        value: '[ERROR] \"API key or API URL not set, please go to extension settings (read README.md for more info)\"',\n      });\n      return;\n    }\n    \n    let chat_response = '';\n    let searchPrompt = \"\";\n    if (prompt!=undefined) {\n      searchPrompt = await this._generate_search_prompt(prompt);\n    } \n    // Show loading indicator\n    this._view?.webview.postMessage({ type: 'setPrompt', value: this._prompt });\n    this._view?.webview.postMessage({ type: 'addResponse', value: '...' });\n\n    if (searchPrompt != \"\") {\n      this._messages?.push({ role: \"user\", content: searchPrompt, selected:true })\n    }\n\n    if (!this._openai) {\n      throw new Error('OpenAI instance is not initialized.');\n    }\n    \n    if (typeof this._settings.model !== 'string') {\n      throw new Error('Model identifier is not valid or not defined.');\n    }\n\n    // Only if you can't change the Message interface\n    const isValidRole = (role: any): role is 'user' | 'assistant' | 'system' => {\n      return ['user', 'assistant', 'system'].includes(role);\n    };\n    \n    // Validate and type narrow `this._messages` before sending\n    if (!this._messages || !Array.isArray(this._messages) ||\n      (!this._messages.every(msg => isValidRole(msg.role)))) {\n      throw new Error('Messages have invalid roles.');\n    }\n\n    const promtNumberOfTokens = this._getMessagesNumberOfTokens();\n    let full_message = \"\";\n    try {\n      console.log(\"Creating message sender...\");\n      \n      let messagesToSend: Array<Message> = [];\n      \n      // Assuming this._messages is defined and is an array\n      for (const message of this._messages) {\n        // Check if 'selected' is true; undefined or false values will be considered false\n        if (message.selected) {\n          //if (messagesToSend.length > 0 && messagesToSend[messagesToSend.length - 1].role === message.role) {\n          //  // Append the content to the previous message if the role is the same\n          //  messagesToSend[messagesToSend.length - 1] = {\n          //\t...messagesToSend[messagesToSend.length - 1],\n          //\tcontent: messagesToSend[messagesToSend.length - 1].content + '\\n' + message.content,\n          //  };\n          //} else {\n            // Add the message as a new entry, omitting the 'selected' key\n            const { selected, ...messageWithoutSelected } = message; // Destructure and omit 'selected'\n            messagesToSend.push(messageWithoutSelected);\n          //}\n        }\n      }\n\n      const stream = await this._openai.chat.completions.create({\n        model: this._settings.model,\n        messages: messagesToSend,\n        stream: true,\n        ...this._settings.options, // Spread operator to include all keys from options\n      });\n      \n      console.log(\"Message sender created\");\n      \n      let completionTokens = 0;\n      full_message = \"\";\n      for await (const chunk of stream) {\n        const content = chunk.choices[0]?.delta?.content || \"\";\n        console.log(\"chunk:\",chunk);\n        console.log(\"content:\", content);\n        const tokenList = this._enc.encode(content);\n        completionTokens += tokenList.length;\n        console.log(\"tokens:\", completionTokens);\n        full_message += content;\n        //this._response = chat_response;\n        this._view?.webview.postMessage({ type: 'addResponse', value: full_message });\n\n      }\n      this._messages?.push({ role: \"assistant\", content: full_message, selected:true })\n      console.log(\"Full message:\", full_message);\n      console.log(\"Full Number of tokens:\", completionTokens);\n      const tokenList = this._enc.encode(full_message);\n      console.log(\"Full Number of tokens tiktoken:\", tokenList.length);\n      chat_response = this._updateChatMessages(promtNumberOfTokens, tokenList.length)\n    } catch (e: any) {\n      console.error(e);\n      if (this._response!=undefined) {\n        this._messages?.push({ role: \"assistant\", content: full_message, selected:true })\n        chat_response = this._response;\n        chat_response += `\\n\\n---\\n[ERROR] ${e}`;\n      }\n    }\n    this._response = chat_response;\n    this._view?.webview.postMessage({ type: 'addResponse', value: chat_response });\n    this._view?.webview.postMessage({ type: 'setPrompt', value: '' });\n  }\n\n  private _getHtmlForWebview(webview: vscode.Webview) {\n  \n    const scriptUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'main.js'));\n    const stylesUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'styles.css'));\n    const microlightUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'scripts', 'microlight.min.js'));\n    const tailwindUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'scripts', 'tailwind.min.js'));\n    const showdownUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'scripts', 'showdown.min.js'));\n  \n    return `<!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n      <meta charset=\"UTF-8\">\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n      <script src=\"${tailwindUri}\"></script>\n      <script src=\"${showdownUri}\"></script>\n      <script src=\"${microlightUri}\"></script>\n      <link rel=\"stylesheet\" href=\"${stylesUri}\">\n    </head>\n    <body>\n      <div id=\"container\">\n        <div id=\"top-wrapper\">\n          <label for=\"provider-selector\">Provider:</label>\n          <select id=\"provider-selector\"></select>\n          <label for=\"model-selector\">Model:</label>\n          <select id=\"model-selector\"></select>\n        </div>\n        <div id=\"response\" class=\"text-sm\"></div>\n        <div id=\"input-wrapper\">\n          <div>\n            <label for=\"system-prompt-selector\">System Prompt:</label>\n            <select id=\"system-prompt-selector\">\n            </select>\n          </div>\n          <input type=\"text\" id=\"prompt-input\" placeholder=\"Ask ChatGPT something\">\n        </div>\n      </div>\n      <script src=\"${scriptUri}\"></script>\n    </body>\n    </html>`;\n  }\n\n  public addImageToChat(imageDataUrl: string, fileName: string) {\n    const imageMarkdown = `![${fileName}](${imageDataUrl})`;\n    let newMessage: UserMessage = { \n      role: \"user\", \n      content: [\n        {\n          \"type\": \"text\",\n          \"text\": fileName + \":\"\n        },\n        {\n          \"type\": \"image_url\",\n          \"image_url\": {\n            \"url\": imageDataUrl\n          }\n        }\n      ], \n      selected: true\n    };\n\n    \n    this._messages?.push(newMessage);\n  \n    const chat_response = this._updateChatMessages(this._getMessagesNumberOfTokens(), 0);\n    this._view?.webview.postMessage({ type: 'addResponse', value: chat_response });\n  }\n\n  public addFileToChat(relativePath: string, fileContent: string, fileExtension: string) {\n    let codeBlock = `**${relativePath}**\\n\\`\\`\\`${fileExtension}\\n${fileContent}\\n\\`\\`\\``;\n  \n    let newMessage: UserMessage = {\n      role: \"user\",\n      content: codeBlock,\n      selected: true\n    };\n  \n    this._messages?.push(newMessage);\n  \n    const chat_response = this._updateChatMessages(this._getMessagesNumberOfTokens(), 0);\n    this._view?.webview.postMessage({ type: 'addResponse', value: chat_response });\n  }\n}\n```"
  selected: true
- role: user
  content: "**src/extension.ts**\n```ts\nimport * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { Provider, Prompt, ProviderSettings } from './types';\nimport { ChatGPTViewProvider } from './chatGptViewProvider';\n\n// Base URL for OpenAI API\nconst BASE_URL = 'https://api.openai.com/v1';\n\nexport function activate(context: vscode.ExtensionContext) {\n\tconsole.log('activating extension \"chatgpt\"');\n\t// Get the settings from the extension's configuration\n\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\n\t// Create a new ChatGPTViewProvider instance and register it with the extension's context\n\tconst provider = new ChatGPTViewProvider(context.extensionUri);\n\n\tlet providers: Provider[] = config.get('providers') || [];\n\tconsole.log(\"Providers:\", providers);\n\n\tlet prompts: Prompt[] = config.get('prompts') || [];\n\tconsole.log(\"prompts:\", prompts);\n\n\tlet activate_provider_settings: ProviderSettings = {\n\t  model: \"none\",\n\t  apiUrl: BASE_URL,\n\t  apiKey: \"none\",\n\t  options: {\n\t\tmaxModelTokens: 1000,\n\t\tmaxResponseTokens: 1000,\n\t\ttemperature: 1.0,\n\t  },\n\t};\n\n\tif (providers && providers.length > 0) {\n\t\tconst firstProvider = providers[0];\n\t\tif (firstProvider.models && firstProvider.models.length > 0) {\n\t\t\tconst firstModel = firstProvider.models[0];\n\t\t\t// Assuming firstModel and firstProvider are already defined based on your JSON structure:\n\t\t\tactivate_provider_settings = {\n\t\t\t  model: firstModel.name,\n\t\t\t  apiUrl: firstProvider.apiUrl,\n\t\t\t  apiKey: firstProvider.apiKey,\n\t\t\t  options: {\n\t\t\t\t...firstModel.options, // Spread operator to include all keys from options\n\t\t\t  },\n\t\t\t};\n\t\t}\n\t}\n\t\n\tprovider.setSettings({\n\t  selectedInsideCodeblock: config.get('selectedInsideCodeblock') || false,\n\t  codeblockWithLanguageId: config.get('codeblockWithLanguageId') || false,\n\t  pasteOnClick: config.get('pasteOnClick') || false,\n\t  keepConversation: config.get('keepConversation') || false,\n\t  timeoutLength: config.get('timeoutLength') || 60,\n\t  apiUrl: activate_provider_settings.apiUrl,\n\t  model: activate_provider_settings.model,\n\t  options: {\n\t\t...activate_provider_settings.options, // Use spread operator to include all options\n\t  },\n\t});\n\n\t// Put configuration settings into the provider\n\tprovider.setAuthenticationInfo({\n\t\tapiKey: activate_provider_settings.apiKey,\n\t\tapiUrl: activate_provider_settings.apiUrl\n\t});\n\t\n\t// Register the provider with the extension's context\n\tcontext.subscriptions.push(\n\t\tvscode.window.registerWebviewViewProvider(ChatGPTViewProvider.viewType, provider, {\n\t\t\twebviewOptions: { retainContextWhenHidden: true }\n\t\t})\n\t);\n\n\tcontext.subscriptions.push(\n\t  vscode.commands.registerCommand('chatgpt.addFileToChat', async (uri: vscode.Uri) => {\n\t\tif (!uri || !uri.fsPath) {\n\t\t  vscode.window.showErrorMessage('No file selected!');\n\t\t  return;\n\t\t}\n\t\ttry {\n\t\t  const fileContent = await fs.promises.readFile(uri.fsPath, 'utf8');\n\t\t  const workspaceFolder = vscode.workspace.getWorkspaceFolder(uri);\n\t\t  let relativePath: string;\n\t\n\t\t  if (workspaceFolder) {\n\t\t\trelativePath = path.relative(workspaceFolder.uri.fsPath, uri.fsPath);\n\t\t  } else {\n\t\t\trelativePath = path.basename(uri.fsPath);\n\t\t  }\n\t\t  let fileExtension = path.extname(relativePath).substring(1);\n\t\n\t\t  let codeBlock = `**${relativePath}**\\n\\`\\`\\`${fileExtension}\\n${fileContent}\\n\\`\\`\\``;\n\t\t  provider.addFileToChat(relativePath, fileContent, fileExtension);  // Adjust method if desired\n\t\t} catch (err) {\n\t\t  vscode.window.showErrorMessage(`Failed to read file: ${err}`);\n\t\t}\n\t  })\n\t);\n\n\tconst commandHandler = (command: string) => {\n\t\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\t\tconst prompt = config.get(command) as string;\n\t\tprovider.search(prompt);\n\t};\n\n\t// Register the commands that can be called from the extension's package.json\n\tcontext.subscriptions.push(\n\t\tvscode.commands.registerCommand('chatgpt.ask', () =>\n\t\t\tvscode.window.showInputBox({ prompt: 'What do you want to do?' })\n\t\t\t\t.then((value) => provider.search(value))\n\t\t),\n\t\tvscode.commands.registerCommand('chatgpt.explain', () => commandHandler('promptPrefix.explain')),\n\t\tvscode.commands.registerCommand('chatgpt.refactor', () => commandHandler('promptPrefix.refactor')),\n\t\tvscode.commands.registerCommand('chatgpt.optimize', () => commandHandler('promptPrefix.optimize')),\n\t\tvscode.commands.registerCommand('chatgpt.findProblems', () => commandHandler('promptPrefix.findProblems')),\n\t\tvscode.commands.registerCommand('chatgpt.documentation', () => commandHandler('promptPrefix.documentation')),\n\t\tvscode.commands.registerCommand('chatgpt.resetConversation', () => provider.resetConversation()),\n\t\tvscode.commands.registerCommand('chatgpt.pasteChat', () => provider.pasteChat()),\n\t\tvscode.commands.registerCommand('chatgpt.useSelectionAsChat', () => provider.useSelectionAsChat())\n\n\t\t\n\t);\n\n\n\t// Change the extension's session token or settings when configuration is changed\n\tvscode.workspace.onDidChangeConfiguration((event: vscode.ConfigurationChangeEvent) => {\n\t\tif (event.affectsConfiguration('chatgpt.providers')) {\n\t\t\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\t\t\tlet providers: Provider[] = config.get('providers') || [];\n\n\t\t\tif (providers && providers.length > 0) {\n\t\t\t\tconst firstProvider = providers[0];\n\t\t\t\tif (firstProvider.models && firstProvider.models.length > 0) {\n\t\t\t\t\tconst firstModel = firstProvider.models[0];\n\t\t\t\t\tactivate_provider_settings = {\n\t\t\t\t\t  model: firstModel.name,\n\t\t\t\t\t  apiUrl: firstProvider.apiUrl,\n\t\t\t\t\t  apiKey: firstProvider.apiKey,\n\t\t\t\t\t  options: {\n\t\t\t\t\t\t...firstModel.options, // Use spread operator to include all options\n\t\t\t\t\t  },\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tprovider.setSettings({\n\t\t\t\t  apiUrl: activate_provider_settings.apiUrl,\n\t\t\t\t  model: activate_provider_settings.model,\n\t\t\t\t  options: {\n\t\t\t\t\t...activate_provider_settings.options, // Use spread operator to include all options\n\t\t\t\t  },\n\t\t\t\t});\n\t\t\t\n\t\t\t\t// Put configuration settings into the provider\n\t\t\t\tprovider.setAuthenticationInfo({\n\t\t\t\t\tapiKey: activate_provider_settings.apiKey,\n\t\t\t\t\tapiUrl: activate_provider_settings.apiUrl\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tprovider.set_providers(providers);//Update the selectors\n\t\t\t}\n\t\t} else if (event.affectsConfiguration('chatgpt.prompts')) {\n\t\t\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\t\t\tlet prompts: Prompt[] = config.get('prompts') || [];\n\n\t\t\tif (prompts && prompts.length > 0) {\n\t\t\t\tconst firstPrompt = prompts[0];\n\t\t\t\tprovider.set_prompt(firstPrompt);\n\t\t\t}\n\t\t\tprovider.set_prompts(prompts);\n\t\t} else if (event.affectsConfiguration('chatgpt.selectedInsideCodeblock')) {\n\t\t\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\t\t\tprovider.setSettings({ selectedInsideCodeblock: config.get('selectedInsideCodeblock') || false });\n\t\t} else if (event.affectsConfiguration('chatgpt.codeblockWithLanguageId')) {\n\t\t\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\t\t\tprovider.setSettings({ codeblockWithLanguageId: config.get('codeblockWithLanguageId') || false });\n\t\t} else if (event.affectsConfiguration('chatgpt.pasteOnClick')) {\n\t\t\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\t\t\tprovider.setSettings({ pasteOnClick: config.get('pasteOnClick') || false });\n\t\t} else if (event.affectsConfiguration('chatgpt.keepConversation')) {\n\t\t\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\t\t\tprovider.setSettings({ keepConversation: config.get('keepConversation') || false });\n\t\t} else if (event.affectsConfiguration('chatgpt.timeoutLength')) {\n\t\t\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\t\t\tprovider.setSettings({ timeoutLength: config.get('timeoutLength') || 60 });\n\t\t}\n\t});\n\n\n\tcontext.subscriptions.push(\n\t\tvscode.commands.registerCommand('chatgpt.addImageToChat', async (uri: vscode.Uri) => {\n\t\t  if (uri && uri.fsPath) {\n\t\t\tconst filePath = uri.fsPath;\n\t\t\tconst fileName = path.basename(filePath);\n\t\t\tconst fileData = await fs.promises.readFile(filePath, { encoding: 'base64' });\n\t\t\tconst fileType = path.extname(filePath).substring(1); // get file extension without dot\n\t\t\tconst imageDataUrl = `data:image/${fileType};base64,${fileData}`;\n\t\n\t\t\t// Post a message to the webview to add the image\n\t\t\tprovider.addImageToChat(imageDataUrl, fileName);\n\t\t  }\n\t\t})\n\t  );\n}\n\n// This method is called when your extension is deactivated\nexport function deactivate() { }\n```"
  selected: true
- role: user
  content: |-
    **src/types.ts**
    ```ts
    import { ChatCompletionAssistantMessageParam, ChatCompletionContentPart, ChatCompletionContentPartImage, ChatCompletionContentPartText, ChatCompletionSystemMessageParam, ChatCompletionUserMessageParam } from 'openai/resources/chat/completions';

    export type AuthInfo = { apiKey?: string, apiUrl?: string };

    export type Settings = {
      selectedInsideCodeblock?: boolean;
      codeblockWithLanguageId?: false;
      pasteOnClick?: boolean;
      keepConversation?: boolean;
      timeoutLength?: number;
      model?: string;
      apiUrl?: string;
      options?: {
        [key: string]: any; // Allows for any number of properties with any value type
      };
    };

    export interface Model {
      name: string;
      options: {
        [key: string]: any; // Allows the `options` object to have any string keys with any value types
      };
    }

    export interface Provider {
      name: string;
      apiKey: string;
      apiUrl: string;
      models: Model[];
    }

    export interface ProviderSettings {
      model: string;
      apiUrl: string;
      apiKey: string;
      options: {
        [key: string]: any; // This allows options to have any number of properties with any types
      };
    }

    export interface Prompt {
      name: string;
      prompt: string;
    }

    export interface SystemMessage extends ChatCompletionSystemMessageParam {
      selected?: boolean;  // Additional property specific to Message
    }

    export interface UserMessage extends ChatCompletionUserMessageParam {
      selected?: boolean;  // Additional property specific to Message
    }

    export interface AssistantMessage extends ChatCompletionAssistantMessageParam {
      selected?: boolean;  // Additional property specific to Message
    }

    export type Message =
      | SystemMessage
      | UserMessage
      | AssistantMessage

    export const BASE_URL = 'https://api.openai.com/v1';
    ```
  selected: true
- role: user
  content: |-
    **package.json**
    ```json
    {
      "name": "diegoaacchatgpt",
      "displayName": "ChatGPT for Visual Studio Code: write and improve code using AI",
      "description": "Use ChatGPT and GPT4 right inside the IDE to enhance and automate your coding with AI-powered assistance (unofficial)",
      "version": "1.1.0",
      "publisher": "diegoaac",
      "icon": "resources/extensionIcon.png",
      "license": "MIT",
      "repository": {
        "url": "https://github.com/timkmecl/chatgpt-vscode"
      },
      "engines": {
        "vscode": "^1.73.0"
      },
      "categories": [
        "Other"
      ],
      "keywords": [
        "chatgpt",
        "openai",
        "gpt3",
        "gpt4",
        "copilot",
        "ai",
        "explain",
        "find bugs",
        "explain ",
        "refactor"
      ],
      "activationEvents": [
        "onView:chatgpt.chatView",
        "onCommand:chatgpt.ask",
        "onCommand:chatgpt.explain",
        "onCommand:chatgpt.refactor",
        "onCommand:chatgpt.optimize",
        "onCommand:chatgpt.findProblems",
        "onCommand:chatgpt.documentation",
        "onCommand:chatgpt.useSelectionAsChat"
      ],
      "main": "./dist/extension.js",
      "contributes": {
        "commands": [
          {
            "command": "chatgpt.ask",
            "title": "Ask ChatGPT"
          },
          {
            "command": "chatgpt.explain",
            "title": "ChatGPT: Explain selection"
          },
          {
            "command": "chatgpt.refactor",
            "title": "ChatGPT: Refactor selection"
          },
          {
            "command": "chatgpt.findProblems",
            "title": "ChatGPT: Find problems"
          },
          {
            "command": "chatgpt.optimize",
            "title": "ChatGPT: Optimize selection"
          },
          {
            "command": "chatgpt.documentation",
            "title": "ChatGPT: Write documentation"
          },
          {
            "command": "chatgpt.resetConversation",
            "title": "Reset ChatGPT conversation"
          },
          {
            "command": "chatgpt.pasteChat",
            "title": "Paste ChatGPT chat"
          },
          {
            "command": "chatgpt.useSelectionAsChat",
            "title": "Use selection as ChatGPT conversation"
          },
          {
            "command": "chatgpt.tryAgain",
            "title": "Retry ChatGPT request"
          },
          {
            "command": "chatgpt.addImageToChat",
            "title": "Add Image to ChatGPT"
          },
          {
            "command": "chatgpt.addFileToChat",
            "title": "Add File Content to ChatGPT"
          }
        ],
        "menus": {
          "editor/context": [
            {
              "command": "chatgpt.ask",
              "when": "editorTextFocus",
              "group": "chatgpt-menu-group@1"
            },
            {
              "command": "chatgpt.explain",
              "when": "editorHasSelection",
              "group": "chatgpt-menu-group@2"
            },
            {
              "command": "chatgpt.refactor",
              "when": "editorHasSelection",
              "group": "chatgpt-menu-group@3"
            },
            {
              "command": "chatgpt.findProblems",
              "when": "editorHasSelection",
              "group": "chatgpt-menu-group@4"
            },
            {
              "command": "chatgpt.optimize",
              "when": "editorHasSelection",
              "group": "chatgpt-menu-group@5"
            },
            {
              "command": "chatgpt.documentation",
              "when": "editorHasSelection",
              "group": "chatgpt-menu-group@6"
            },
            {
              "command": "chatgpt.useSelectionAsChat",
              "when": "editorHasSelection",
              "group": "chatgpt-menu-group@7"
            }
          ],
          "commandPalette": [
            {
              "command": "chatgpt.ask"
            },
            {
              "command": "chatgpt.explain",
              "when": "editorHasSelection"
            },
            {
              "command": "chatgpt.refactor",
              "when": "editorHasSelection"
            },
            {
              "command": "chatgpt.findProblems",
              "when": "editorHasSelection"
            },
            {
              "command": "chatgpt.optimize",
              "when": "editorHasSelection"
            },
            {
              "command": "chatgpt.documentation",
              "when": "editorHasSelection"
            },
            {
              "command": "chatgpt.resetConversation"
            },
            {
              "command": "chatgpt.pasteChat"
            },
            {
              "command": "chatgpt.useSelectionAsChat",
              "when": "editorHasSelection"
            }
          ],
          "explorer/context": [
            {
              "command": "chatgpt.addImageToChat",
              "when": "resourceExtname == .png || resourceExtname == .jpg || resourceExtname == .jpeg || resourceExtname == .gif",
              "group": "navigation"
            },
            {
              "command": "chatgpt.addFileToChat",
              "when": "resourceLangId =~ /^((javascript)|(typescript)|(python)|(json)|(markdown)|(plaintext)|(cpp)|(c)|(java)|(xml)|(html)|(css)|(shellscript)|(yaml)|(toml)|(ini)|(go)|(ruby)|(php)|(rust)|(csharp)|(plaintext))$/",
              "group": "navigation"
            }
          ]
        },
        "viewsContainers": {
          "activitybar": [
            {
              "id": "chatgpt",
              "title": "ChatGPT",
              "icon": "resources/icon.png"
            }
          ]
        },
        "views": {
          "chatgpt": [
            {
              "type": "webview",
              "id": "chatgpt.chatView",
              "name": "ChatGPT"
            }
          ]
        },
        "configuration": {
          "title": "chatGPT",
          "type": "object",
          "properties": {
            "chatgpt.providers": {
              "type": "array",
              "description": "List of AI providers with their configurations.",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the provider (e.g., OpenAI, CustomAPI)."
                  },
                  "apiKey": {
                    "type": "string",
                    "description": "API key for the provider."
                  },
                  "apiUrl": {
                    "type": "string",
                    "description": "API URL for the provider."
                  },
                  "models": {
                    "type": "array",
                    "description": "List of models offered by this provider.",
                    "items": {
                      "type": "object",
                      "properties": {
                        "name": {
                          "type": "string",
                          "description": "Name of the model (e.g., gpt-3.5-turbo)."
                        },
                        "options": {
                          "type": "object",
                          "description": "Options for the model.",
                          "additionalProperties": {
                            "type": "any",
                            "description": "Custom option key-value pairs for the model."
                          }
                        }
                      },
                      "required": ["name"]
                    }
                  }
                },
                "required": ["name", "apiKey", "apiUrl", "models"]
              },
              "order": 1
            },
            "chatgpt.prompts" : {
              "type":"array",
              "description": "List of possible prompts to use",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the prompt (e.g., ChainOfThougt, Simple Engenier)."
                  },
                  "prompt": {
                    "type": "string",
                    "description": "The prompt it self"
                  }
                },
                "required": ["name", "prompt"]
              },
              "order": 2
            },
            "chatgpt.pasteOnClick": {
              "type": "boolean",
              "default": true,
              "description": "Paste the code from a codeblock inside the response into the editor when you click on it",
              "order": 3
            },
            "chatgpt.promptPrefix.explain": {
              "type": "string",
              "default": "Explain what this code does: ",
              "description": "The prompt prefix used for explaining the selected code",
              "order": 4
            },
            "chatgpt.promptPrefix.refactor": {
              "type": "string",
              "default": "Refactor this code and explain what's changed: ",
              "description": "The prompt prefix used for refactoring the selected code",
              "order": 5
            },
            "chatgpt.promptPrefix.findProblems": {
              "type": "string",
              "default": "Find problems with the following code, fix them and explain what was wrong (Do not change anything else, if there are no problems say so): ",
              "description": "The prompt prefix used for finding problems in the selected code",
              "order": 6
            },
            "chatgpt.promptPrefix.documentation": {
              "type": "string",
              "default": "Write documentation for the following code: ",
              "description": "The prompt prefix used for writing documentation for the selected code",
              "order": 7
            },
            "chatgpt.promptPrefix.optimize": {
              "type": "string",
              "default": "Optimize the following code if there is anything to improve, if not say so: ",
              "description": "The prompt prefix used for optimizing the selected code",
              "order": 8
            },
            "chatgpt.keepConversation": {
              "type": "boolean",
              "default": true,
              "description": "Keep the conversation going by using the same conversation ID for all requests (allows follow-up questions)",
              "order": 9
            },
            "chatgpt.timeoutLength": {
              "type": "number",
              "default": "120",
              "description": "How long should the request wait for a response before timing out (in seconds)",
              "order": 10
            },
            "chatgpt.selectedInsideCodeblock": {
              "type": "boolean",
              "default": true,
              "description": "Append selected code as a codeblock (```...code...```) instead of plain text",
              "order": 11
            },
            "chatgpt.codeblockWithLanguageId": {
              "type": "boolean",
              "default": true,
              "description": "Append language id of the selected code to the codeblock (```language...code...```)",
              "order": 12
            }
          }
        }
      },
      "scripts": {
        "vscode:prepublish": "yarn run package",
        "compile": "webpack",
        "watch": "webpack --watch",
        "package": "webpack --mode production --devtool hidden-source-map",
        "compile-tests": "tsc -p . --outDir out",
        "watch-tests": "tsc -p . -w --outDir out",
        "pretest": "yarn run compile-tests && yarn run compile && yarn run lint",
        "lint": "eslint src --ext ts",
        "test": "node ./out/test/runTest.js",
        "update-package-lock": "npm install --package-lock-only"
      },
      "devDependencies": {
        "@types/glob": "^8.0.0",
        "@types/js-yaml": "^4.0.9",
        "@types/mocha": "^10.0.1",
        "@types/node": "16.x",
        "@types/vscode": "^1.73.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "@vscode/test-electron": "^2.2.0",
        "eslint": "^8.28.0",
        "glob": "^8.0.3",
        "mocha": "^10.1.0",
        "ts-loader": "^9.4.1",
        "typescript": "^4.9.3",
        "webpack": "^5.75.0",
        "webpack-cli": "^5.0.0"
      },
      "dependencies": {
        "@types/node-fetch": "^2.6.11",
        "js-tiktoken": "^1.0.10",
        "js-yaml": "^4.1.0",
        "node-fetch": "^3.3.2",
        "openai": "^4.29.2"
      }
    }

    ```
  selected: true
- role: user
  content: "**webpack.config.js**\n```js\n//@ts-check\n\n'use strict';\n\nconst path = require('path');\n\n//@ts-check\n/** @typedef {import('webpack').Configuration} WebpackConfig **/\n\n/** @type WebpackConfig */\nconst extensionConfig = {\n  target: 'node', // VS Code extensions run in a Node.js-context 📖 -> https://webpack.js.org/configuration/node/\n\tmode: 'none', // this leaves the source code as close as possible to the original (when packaging we set this to 'production')\n\n  entry: './src/extension.ts', // the entry point of this extension, 📖 -> https://webpack.js.org/configuration/entry-context/\n  output: {\n    // the bundle is stored in the 'dist' folder (check package.json), 📖 -> https://webpack.js.org/configuration/output/\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'extension.js',\n    libraryTarget: 'commonjs2'\n  },\n  externals: {\n    'playwright-core': 'commonjs2 playwright-core',\n    vscode: 'commonjs vscode' // the vscode-module is created on-the-fly and must be excluded. Add other modules that cannot be webpack'ed, 📖 -> https://webpack.js.org/configuration/externals/\n    // modules added here also need to be added in the .vscodeignore file\n  },\n  resolve: {\n    // support reading TypeScript and JavaScript files, 📖 -> https://github.com/TypeStrong/ts-loader\n    extensions: ['.ts', '.js']\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        exclude: /node_modules/,\n        use: [\n          {\n            loader: 'ts-loader'\n          }\n        ]\n      }\n    ]\n  },\n  devtool: 'nosources-source-map',\n  infrastructureLogging: {\n    level: \"log\", // enables logging required for problem matchers\n  },\n};\nmodule.exports = [ extensionConfig ];\n```"
  selected: true
- role: user
  content: "tsconfig.json:\n```jsonc\n{\n\t\"compilerOptions\": {\n\t\t\"module\": \"commonjs\",\n\t\t\"target\": \"ES2020\",\n\t\t\"lib\": [\n\t\t\t\"ES2020\"\n\t\t],\n\t\t\"sourceMap\": true,\n\t\t\"rootDir\": \"src\",\n\t\t\"strict\": true   /* enable all strict type-checking options */\n\t\t/* Additional Checks */\n\t\t// \"noImplicitReturns\": true, /* Report error when not all code paths in function return a value. */\n\t\t// \"noFallthroughCasesInSwitch\": true, /* Report errors for fallthrough cases in switch statement. */\n\t\t// \"noUnusedParameters\": true,  /* Report errors on unused parameters. */\n\t}\n}\n\n```"
  selected: true
- role: user
  content: |-
    **current_settings/prompts.json**
    ```json
    {
        "chatgpt.prompts": [  
            {
                "name": "Simplest Prompt",
                "prompt": "You are a helpfull assistant."
            },
            {
                "name": "AI auto assistant (generate project_description_for_ai.md)",
                "prompt": "You are to generate a `project_description_for_ai.md` file that fully describes the project, with the goal of enabling an AI agent to confidently understand, modify, and extend any part of the project.\nBegin by requesting the project directory tree from the user.\nSystematically identify which files, scripts, or resources are necessary for a complete understanding of the project structure, logic, and extensibility. Request these files from the user as needed.\nCarefully review the files provided. If additional information or files are required to ensure the AI agent can perform safe and effective modifications, request them from the user.\nAfter gathering enough context, produce a `project_description_for_ai.md` file containing the following sections, each written with a focus on making future modifications and extensions as straightforward as possible for an AI agent:\n# Steps\n1. **Request Project Directory Tree**: Ask the user to provide the project’s directory structure.\n2. **Identify Key Files for Modification**: Determine which files and resources are most important for understanding and changing project behavior or structure, and request them from the user.\n3. **Review and Request Supplementary Files**: Analyze provided files for completeness and request further files as necessary for modification tasks.\n4. **Compile Modification-Focused Documentation**: Collate all information required for an AI agent to make any changes or extensions.\n5. **Generate `project_description_for_ai.md`**: Write the markdown file, structured as described.\n# Output Format\nYour output should be a markdown file named `project_description_for_ai.md`, organized as follows:\n1. **Project Overview**: Concise explanation of the project’s purpose and main features.\n2. **Project Directory Tree**: The root-to-leaf structure of files and folders.\n3. **File-by-File Explanation**: Detailed descriptions of each significant file, focusing on their function, how they work together, and which parts are most relevant for modification.\n4. **Important Design Notes for Modification**: Explain architectural decisions, extensibility points, and where/how changes should be made for different types of modifications.\n5. **Security Considerations**: Outline current security practices and highlight any areas where modifications could introduce vulnerabilities.\n6. **Summary Table of Extensible Components**: Table listing primary files, modules, or locations in the codebase that are important for extending or modifying the project, with a brief on what can safely be changed.\n7. **Final Notes**: Supplementary thoughts, development conventions, or anything critical for an AI agent to know before making changes.\n# Guidance\n- Write all instructions and descriptions with the explicit goal of enabling a non-human agent to safely and effectively modify, extend, or refactor the project.\n- Use technical language aligned with the project’s domain or stack.\n- Highlight interfaces, APIs, configuration files, or extension points that are relevant for programmatic modification.\n- Explicitly address potential risks or architectural pitfalls that an agent should consider when making changes.\n- Ensure documentation is comprehensive and actionable for an AI agent with no prior context of the project."
            },
            {
                "name": "AI auto assistant (use project_description_for_ai.md)",
                "prompt": "Use the `project_description_for_ai.md` file as a reference to understand and modify the project you are working on. If you need access to a specific project file (always prioritize access to files before provide an answer, do not make assumptions), request access to it. Provide modifications to the code based on user requests.\n# Steps\n1. **Understanding**: Use the `project_description_for_ai.md` file to comprehend the project's overall structure, objectives, and important components.\n2. **Evaluation**: Always request acces to project files when are needed to fulfill the user's modification request. If you need to acces file(s) (do not make assumptions) do not provide an answer, just ask for the file(s) access.\n3. **Request**: If necessary, request access to specific other project files or external libraries information to gather further details or context. If you need to acces file(s) or libraries (do not make assumptions) do not provide an answer, just ask for the file(s) (or library(es)) access.\n4. **Modification**: Based on the provided or requested information, propose code modifications as per the user's requests.\n# Output Format\nProvide the proposed modifications in clear, structured markdown. Include:\n- A brief explanation of the changes.\n- The modified code snippet.\n- Any limitations.\n# Notes\n- Ensure clarity in communication by defining technical terms when necessary.\n- Verify all changes align with the project's original design goals and constraints.\n- If there is uncertainty about the project’s structure or dependencies, request clarification or further details from the user."
            },
            {
                "name": "Developer with Verbosity",
                "prompt": "Simulate an expert developer with extensive knowledge in C++, JavaScript, Python, and a wide range of programming languages to provide accurate, detailed, and insightful responses to programming-related queries. Allow the user to express the desired verbosity of the response, using a number and keyword, for example, \"verbosity: 2 concise\" or \"verbosity: 4 comprehensive.\"\n\n# Steps\n\n- **Identify the programming language** relevant to the query.\n- **Analyze** the given problem or task related to the identified language.\n- **Apply advanced knowledge and concepts** from the specific language to devise a solution or provide guidance.\n- **Explain the reasoning** behind each step or solution provided tailored to the verbosity level.\n- **Consider alternative approaches** if applicable and discuss their advantages or disadvantages.\n\n# Output Format\n\nProvide a comprehensive response that includes a step-by-step explanation or reasoning followed by the conclusion or solution. Use concise and clear language suitable for a professional developer audience. Adapt the response length and detail to match the user's specified verbosity level. The output ranges can be:\n- **1 Minimal**: A very brief overview or direct answer.\n- **2 Concise**: A short explanation with key points.\n- **3 Detailed**: A moderate explanation with reasoning.\n- **4 Comprehensive**: An in-depth explanation with extensive reasoning and examples.\n\n# Examples\n\n**Example 1:**\n\n**Input:** \"How do I implement a binary search algorithm in C++?\"\n**Verbosity:** 3 detailed  \n\n**Output:**\n\n*Step-by-step Reasoning:*\n1. Understand that a binary search algorithm efficiently finds the position of a target value within a sorted array.\n2. Recognize the requirement to work with a sorted array as binary search cannot be applied to unsorted data.\n3. Describe initializing two pointers, one for the start and one for the end of the array.\n\n*Conclusion:*\n\nTo implement a binary search in C++:\n\n```cpp\nint binarySearch(const std::vector<int>& arr, int target) {\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) return mid;\n        if (arr[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1; // Target not found\n}\n```\n\n**Example 2:**\n\n**Input:** \"Explain closure in JavaScript and provide an example.\"\n**Verbosity:** 2 concise  \n\n**Output:**\n\n*Step-by-step Reasoning:*\n1. Define a closure as a feature where an inner function has access to the outer function’s variables.\n2. Explain the concept of lexical scoping where functions remember the scope in which they were created.\n\n*Conclusion:*\n\nIn JavaScript, closures are functions that have access to the outer function's variable environment. Here’s an example:\n\n```javascript\nfunction outerFunction(outerVariable) {\n    return function innerFunction(innerVariable) {\n        console.log('Outer Variable: ' + outerVariable);\n        console.log('Inner Variable: ' + innerVariable);\n    }\n}\n\nconst newFunction = outerFunction('outside');\nnewFunction('inside');\n// Output:\n// Outer Variable: outside\n// Inner Variable: inside\n```\n\n# Notes\n\n- Prepare to address complex problems involving multi-language integration.\n- Be ready to compare language features if relevant to the user's query.\n- Maintain up-to-date and accurate knowledge of programming best practices.\n- Use the verbosity control to adjust the level of detail, ensuring it matches the user's specification."
            },
            {
                "name": "Software architect",
                "prompt": "You are a software architect tasked with defining the architecture of software at various levels of abstraction. Focus on designing robust, scalable, and efficient software architectures by considering the system's requirements, constraints, and best practices.\n\n# Steps\n\n1. **Analyze Requirements**: Thoroughly review the software requirements to understand functional and non-functional needs.\n2. **Identify Key Components**: Develop a comprehensive list of the major components or modules needed for the system.\n3. **Design Patterns**: Select appropriate design patterns that best fit the system architecture and address specific challenges.\n4. **Define Interfaces**: Determine clear and consistent interfaces for communication between different components or layers.\n5. **Technology Stack**: Choose suitable technologies, programming languages, and frameworks that align with the system requirements.\n6. **Scalability & Performance**: Consider scalability and performance factors, ensuring that the system can handle expected load and growth.\n7. **Security Considerations**: Identify potential security risks and propose mitigation strategies.\n8. **Documentation**: Prepare clear architectural diagrams and documentation for reference and understanding by stakeholders.\n\n# Output Format\n\nProvide an in-depth architectural overview in prose format, covering each step and including diagrams if applicable. The document should include:\n- A brief summary of key findings and decisions at the beginning.\n- A detailed explanation of each architectural component and decision.\n- Architectural diagrams or sketches, referenced within the text.\n- Any assumptions or considerations taken into account.\n\n# Examples \n\n## Example 1\n\n### Input: \n- **System Requirements**: E-commerce platform capable of managing user accounts, product listings, orders, and payments.\n- **Constraints**: Must support up to 10,000 simultaneous users; must comply with PCI DSS standards.\n\n### Output:\n- **Summary**: An e-commerce platform architecture using microservices to handle core features with a focus on scalability and security.\n- **Components**: User Service, Product Service, Order Service, Payment Gateway.\n- **Design Patterns**: Microservice architecture, event-driven communication.\n- **Interfaces**: RESTful APIs for inter-service communication.\n- **Technology Stack**: Node.js, MongoDB, RabbitMQ, Docker.\n- **Scalability & Performance**: Use of load balancers and database sharding.\n- **Security Considerations**: Implement authentication via OAuth2, encrypt sensitive data.\n- **Documentation**: Includes a diagram showing component interactions and data flow.\n\n(Real examples should be detailed and provide a thorough reasoning process behind each architectural decision.)\n\n# Notes\n\n- Ensure that the architectures are both innovative and practical, balancing cutting-edge solutions with stability.\n- Consider cultural and domain-specific practices if provided with regional or industry-specific requirements."
            },
            {
                "name": "Chain of Thought",
                "prompt": "Think step by step to answer the following question. Start the think process with <think> label. After thinking close the label with </think> and then Return the answer."
            },
            {
                "name": "Chain of Draft",
                "prompt": "Think step by step (but only keep a minimum draft for each thinking step, with 5 words at most) to answer the following question. Start the think process with <think> label. After thinking close the label with </think> and then Return the answer."
            }
        ]
        
    ```
  selected: true
- role: user
  content: |-
    **current_settings/providers.json**
    ```json
    {
        "chatgpt.providers": [
            {
                "name": "OpenAI",
                "apiKey": "OPENAI_API_KEY",
                "apiUrl": "https://api.openai.com/v1",
                "models": [
                    {
                        "name": "gpt-4o",
                        "options": {
                            "temperature": 1.0
                        }
                    },
                    {
                        "name": "gpt-4o-mini",
                        "options": {
                            "temperature": 1.0
                        }
                    },
                    {
                        "name": "gpt-4.1",
                        "options": {
                            "temperature": 1.0
                        }
                    },
                    {
                        "name": "gpt-4.1-mini",
                        "options": {
                            "temperature": 1.0
                        }
                    },
                    {
                        "name": "gpt-4.1-nano",
                        "options": {
                            "temperature": 1.0
                        }
                    },
                    {
                        "name": "o3",
                        "options": {
                        }
                    },
                    {
                        "name": "o3-mini",
                        "options": {
                        }
                    },
                    {
                        "name": "o4-mini",
                        "options": {
                        }
                    },
                    {
                        "name": "o4-mini-high",
                        "options": {
                        }
                    },
                ]
            },
            {
                "name": "Gemini",
                "apiKey": "GEMINI_API_KEY",
                "apiUrl": "https://generativelanguage.googleapis.com/v1beta/openai/",
                "models": [
                    {
                        "name": "gemini-1.5-flash",
                        "options": {
                            "temperature": 1.0
                        }
                    },
                    {
                        "name": "gemini-2.5-pro-exp-03-25",
                        "options": {
                        }
                    }
                ]
            },
            {
                "name": "OpenRouter",
                "apiKey": "OPENROUTER_API_KEY",
                "apiUrl": "https://openrouter.ai/api/v1",
                "models": [
                    {
                        "name": "google/gemini-2.5-pro-exp-03-25:free",
                        "options": {
                        }
                    },
                    {
                        "name": "deepseek/deepseek-chat",
                        "options": {
                            "temperature": 1.0
                        }
                    },
                    {
                        "name": "mistralai/mistral-large-2411",
                        "options": {
                            "temperature": 1.0
                        }
                    },
                    {
                        "name": "cognitivecomputations/dolphin-mixtral-8x22b",
                        "options": {
                            "temperature": 1.0
                        }
                    },
                    {
                        "name": "anthropic/claude-3.5-sonnet",
                        "options": {
                        }
                    },
                    {
                        "name": "anthropic/claude-3.7-sonnet",
                        "options": {
                        }
                    },
                    {
                        "name": "anthropic/claude-3.7-sonnet:thinking",
                        "options": {
                        }
                    },
                    {
                        "name": "openai/o1-preview",
                        "options": {
                        }
                    },
                    {
                        "name": "openai/o3-mini",
                        "options": {
                        }
                    },
                    {
                        "name": "openai/o3-mini-high",
                        "options": {
                        }
                    },
                    {
                        "name": "openai/gpt-4.5-preview",
                        "options": {
                            "temperature": 1.0
                        }
                    },
                    {
                        "name": "deepseek/deepseek-r1",
                        "options": {
                        }
                    },
                    {
                        "name": "deepseek/deepseek-r1-distill-llama-70b:free",
                        "options": {
                        }
                    },
                    {
                        "name": "deepseek/deepseek-r1-distill-llama-70b",
                        "options": {
                        }
                    },
                ]
            },
            {
                "name": "Ollama",
                "apiKey": "OLLAMA_API_KEY",
                "apiUrl": "http://localhost:11434/v1",
                "models": [
                    {
                        "name": "deepseek-r1:1.5b",
                        "options": {
                            "temperature": 1.0
                        }
                    },
                    {
                        "name": "llama3.2:1b",
                        "options": {
                            "temperature": 1.0
                        }
                    },
                    {
                        "name": "qwen2.5-coder:0.5b",
                        "options": {
                            "temperature": 1.0
                        }
                    }
                ]
            },
            {
                "name": "Groq",
                "apiKey": "GROQ_API_KEY",
                "apiUrl": "https://api.groq.com/openai/v1",
                "models": [
                    {
                        "name": "Deepseek-R1-Distill-Llama-70b",
                        "options": {
                        }
                    },
                    {
                        "name": "Llama-3.3-70b-Specdec",
                        "options": {
                            "temperature": 1.0
                        }
                    }
                ]
            }
        ]
    }
    ```
  selected: true
- role: user
  content: |-
    **media/main.js**
    ```js
    // @ts-ignore

    // This script will be run within the webview itself
    // It cannot access the main VS Code APIs directly.
    (function () {
        const vscode = acquireVsCodeApi();

        let response = '';
        let providers = []; // To store providers
        let prompts = []; 
        let models = []; // To store models for the selected provider
        let selectedProviderIndex = 0;

        // Function to populate the provider and model selectors
        function populateSelectors(providers, selectedProviderIndex = 0, selectedModelIndex = 0) {
            const providerSelector = document.getElementById('provider-selector');
            providerSelector.innerHTML = ''; // Clear existing options
            providers.forEach((provider, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = provider.name;
                providerSelector.appendChild(option);
            });

            if (providers.length > 0) {
                providerSelector.value = selectedProviderIndex; // Set default selection
                models = providers[selectedProviderIndex].models;
            }

            const modelSelector = document.getElementById('model-selector');
            modelSelector.innerHTML = ''; // Clear existing options
            models.forEach((model, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = model.name;
                modelSelector.appendChild(option);
            });

            if (models.length > 0) {
                modelSelector.value = selectedModelIndex; // Set default selection
            }
        }

        function populatePrompts(prompts, selectedPromptIndex = 0) {
            const promptSelector = document.getElementById('system-prompt-selector');
            promptSelector.innerHTML = ''; // Clear existing options
            prompts.forEach((prompt, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = prompt.name;
                promptSelector.appendChild(option);
            });

            if (prompts.length > 0) {
                promptSelector.value = selectedPromptIndex; // Set default selection
                //models = providers[selectedProviderIndex].models;
            }
        }

        window.addEventListener('load', () => {
            // Notify the extension that the webview is ready
            vscode.postMessage({ type: 'ready' });
        });
        
        // Note: Ensure you import the vscode API object correctly in your web script.
        
        // Handle messages sent from the extension to the webview
        window.addEventListener("message", (event) => {
            const message = event.data;
            switch (message.type) {
                case "addResponse": {
                    response = message.value;
                    setResponse();
                    break;
                }
                case "updateResponse": {
                    console.log("Update Response!!!!!");
                    setResponse();
                    console.log("After Update Response !!!!!!!!!");
                    break;                
                }
                case "clearResponse": {
                    response = '';
                    break;
                }
                case "setPrompt": {
                    document.getElementById("prompt-input").value = message.value;
                    break;
                }
                case "initialize": { 
                    providers = message.value;
                    populateSelectors(providers);
                    break;
                }

                case "initialize_prompts": {
                    console.log("Initialize Prompts:", message.value); 
                    prompts = message.value;
                    populatePrompts(prompts);
                    break;
                }
            }
        });

        showdown.extension('thinkExtension', function() {
            return [
              {
                type: 'lang', // Process block-level syntax
                regex: /<think>([\s\S]*?)<\/think>/g,
                replace: function(match, content) {
                  // Trim and process lines, ensuring let's handle `<p>` tags ourselves
                  const pTags = content.trim().split('\n').map(line => {
                    if (line.trim()) {
                      return `<p>${line.trim()}</p>`;
                    }
                    return '';
                  }).join('');
          
                  return `<think>${pTags}</think>`;
                }
              },
              {
                type: 'output', // After markdown is converted to HTML
                filter: function(text) {
                  // Remove wrapping <p> tags around <think> elements
                  return text.replace(/<p><think>/g, '<think>').replace(/<\/think><\/p>/g, '</think>');
                }
              }
            ];
        });

        function fixCodeBlocks(response) {
            const REGEX_CODEBLOCK = new RegExp('```', 'g');
            const matches = response.match(REGEX_CODEBLOCK);

            const count = matches ? matches.length : 0;
            return count % 2 === 0 ? response : response.concat('\n```');
        }

        function setResponse() {
            var converter = new showdown.Converter({
                omitExtraWLInCodeBlocks: true,
                simplifiedAutoLink: true,
                excludeTrailingPunctuationFromURLs: true,
                literalMidWordUnderscores: true,
                simpleLineBreaks: true,
                extensions: ['thinkExtension']
            });

            
            console.log("!!!!!!!!!!!!!!!!!!!!!Response!!!!!!!!!!!!");
            console.log(response)
            console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
            response = fixCodeBlocks(response);
            console.log("!!!!!!!!!!!!!!!!!!!!!FixCodeBlockResponse!!!!!!!!!!!!");
            console.log(response)
            console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
            const html = converter.makeHtml(response);
            console.log("!!!!!!!!!!!!!!!!!!!!!HTML!!!!!!!!!!!!");
            console.log(html)
            console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
            const responseDiv = document.getElementById("response");
            responseDiv.innerHTML = html;

            var preCodeBlocks = document.querySelectorAll("pre code");
            for (var i = 0; i < preCodeBlocks.length; i++) {
                preCodeBlocks[i].classList.add(
                    "p-2",
                    "my-2",
                    "block",
                    "overflow-x-scroll"
                );
            }

            var codeBlocks = document.querySelectorAll('code');
            codeBlocks.forEach(codeBlock => {
                if (codeBlock.innerText.startsWith("Copy code")) {
                    codeBlock.innerText = codeBlock.innerText.replace("Copy code", "");
                }

                codeBlock.classList.add("inline-flex", "max-w-full", "overflow-hidden", "rounded-sm", "cursor-pointer");

                codeBlock.addEventListener('click', function (e) {
                    e.preventDefault();
                    vscode.postMessage({
                        type: 'codeSelected',
                        value: this.innerText
                    });
                });

                const d = document.createElement('div');
                d.innerHTML = codeBlock.innerHTML;
                codeBlock.innerHTML = null;
                codeBlock.appendChild(d);
                d.classList.add("code");
            });

            microlight.reset('code');
            responseDiv.scrollTop = responseDiv.scrollHeight;
        }

        document.getElementById('prompt-input').addEventListener('paste', async function (e) {
            const clipboardItems = e.clipboardData.items;
            for (const item of clipboardItems) {
                if (item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    const reader = new FileReader();
                    reader.onload = function (event) {
                        const base64Data = event.target.result;
                        vscode.postMessage({
                            type: 'pasteImage',
                            value: base64Data
                        });
                    };
                    reader.readAsDataURL(file);
                }
            }
        });

        document.getElementById('prompt-input').addEventListener('keyup', function (e) {
            if (e.key === "Enter" && !e.ctrlKey) {
                vscode.postMessage({
                    type: 'prompt',
                    value: this.value
                });
            }
            else if (e.key === "Enter" && e.ctrlKey) {
                vscode.postMessage({
                    type: 'promptNoQuery',
                    value: this.value
                });
            }
        });

        document.getElementById('provider-selector').addEventListener('change', function () {
            selectedProviderIndex = parseInt(this.value, 10);
            models = providers[selectedProviderIndex].models;
            populateSelectors(providers, selectedProviderIndex, 0);
            vscode.postMessage({
                type: 'providerModelChanged',
                providerIndex: selectedProviderIndex,
                modelIndex: 0
            });
        });

        document.getElementById('model-selector').addEventListener('change', function () {
            const selectedModelIndex = parseInt(this.value, 10);
            vscode.postMessage({
                type: 'providerModelChanged',
                providerIndex: selectedProviderIndex,
                modelIndex: selectedModelIndex,
            });
        });

        document.getElementById('system-prompt-selector').addEventListener('change', function () {
            const systemPromptIndex = parseInt(this.value, 10);
            vscode.postMessage({
                type: 'systemPromptChanged',
                systemPromptIndex: systemPromptIndex
            });
        });

        //document.getElementById('temperature-slider').addEventListener('input', function () {
        //    const temperature = parseInt(this.value, 10) / 100;
        //    vscode.postMessage({
        //        type: 'temperatureChanged',
        //        temperature: temperature,
        //    });
        //});

        window.myFunction = function (checkboxElem) {
            vscode.postMessage({
                type: 'checkboxChanged',
                id: checkboxElem.id,
                checked: checkboxElem.checked
            });
        }

        window.makeEditable = function (element) {
            element.contentEditable = 'true';
            element.focus();
        }

        window.saveContent = function (element) {
            element.contentEditable = 'false';
            const updatedContent = element.innerText;
            vscode.postMessage({
                type: 'messageContentChanged',
                id: element.id,
                value: updatedContent,
            });
        }

    })();
    ```
  selected: true
- role: user
  content: |-
    **media/styles.css**
    ```css
    .code {
        white-space: pre;
    }
    p {
        padding-top: 0.3rem;
        padding-bottom: 0.3rem;
    }

    ul {
        list-style: initial !important;
        margin-left: 10px !important;
    }

    ol {
        list-style-type: decimal !important;
        list-style-position: outside;
        padding-left: 40px; /* Adjust as needed to ensure numbers are visible */
        margin-left: 20px !important; /* Reset margin to see true boundaries */
    }



    h1, h2, h3, h4, h5, h6 {
        font-weight: bold !important;
    }

    body, html {
        height: 100%;
        margin: 0;
    }
    #container {
        display: flex;
        flex-direction: column;
        height: 100vh;
    }
    #top-wrapper {
        flex-shrink: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: var(--vscode-editor-background);
        border-bottom: 1px solid var(--vscode-editorGroup-border);
        padding: 10px;
        box-sizing: border-box;
        z-index: 1;
        height: 50px;
    }
    #response {
        flex-grow: 1;
        overflow-y: auto;
        padding: 10px;
        padding-top: 60px;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    #input-wrapper {
        flex-shrink: 0;
        display: grid;
        grid-template-columns: auto 1fr;
        grid-template-rows: auto auto;
        grid-gap: 10px;
        align-items: center;
        background-color: var(--vscode-editor-background);
        border-top: 1px solid var(--vscode-editorGroup-border);
        padding: 10px;
        box-sizing: border-box;
    }
    #prompt-input {
        grid-column: 1 / -1;
        color: var(--vscode-editor-foreground);
        background-color: var(--vscode-editor-background);
        border: 1px solid var(--vscode-editorGroup-border);
        outline: none;
        padding: 10px;
        width: calc(100% - 22px);
    }

    #model-selector, #temperature-slider, label[for="temperature-slider"] {
        margin-bottom: 10px;
    }

    think {
        display: inline; /* Ensure it doesn't visually affect layout like block */
        color: lightblue !important; /* Use !important to override other styles */
        font-style: italic !important; /* Also use !important for emphasis */
    }



    select {
        color: var(--vscode-dropdown-foreground);
        background-color: var(--vscode-dropdown-background);
        border: 1px solid var(--vscode-dropdown-border);
        padding: 5px;
        font-size: inherit;
        cursor: pointer;
    }

    select option {
        background: var(--vscode-dropdown-listBackground);
    }

    input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        background-color: var(--vscode-slider-background);
        height: 2px;
        border-radius: 0;
        outline: none;
        cursor: pointer;
    }

    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        background: var(--vscode-slider-knob);
        height: 16px;
        width: 16px;
        border: none;
        border-radius: 50%;
        margin-top: -7px;
    }

    input[type="range"]::-moz-range-thumb {
        background: var(--vscode-slider-knob);
        height: 16px;
        width: 16px;
        border: none;
        border-radius: 50%;
    }

    input[type="range"]::-ms-thumb {
        background: var(--vscode-slider-knob);
        height: 16px;
        width: 16px;
        border: none;
        border-radius: 50%;
    }

    #top-wrapper {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: var(--vscode-editor-background);
        border-bottom: 1px solid var(--vscode-editorGroup-border);
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        padding: 10px;
        box-sizing: border-box;
        z-index: 1;
    }

    #top-wrapper input[type="text"], #top-wrapper select, #top-wrapper button {
        margin: 0 5px;
    }

    #top-wrapper button {
        padding: 5px 15px;
    }

    :root {
        --vscode-dropdown-foreground: #C5C5C5;
        --vscode-dropdown-background: #3C3C3C;
        --vscode-dropdown-border: #303030;
        --vscode-dropdown-listBackground: #252526;
        --vscode-slider-background: #C5C5C5;
        --vscode-slider-activeBackground: #007ACC;
        --vscode-slider-knob: #CCCCCC;
    }
    ```
  selected: true
- role: user
  content: Those are all the files you requested
  selected: true
- role: assistant
  content: |-
    project_description_for_ai.md

    # Project Overview

    This project is a Visual Studio Code extension titled **"ChatGPT for Visual Studio Code: write and improve code using AI"**. It enables developers to interact with various AI language models (including but not limited to OpenAI's ChatGPT and GPT-4, Gemini, OpenRouter, Ollama, Groq) directly within the IDE through a chat-style interface. Users can ask questions, request code explanations, refactorings, optimizations, and more, leveraging configurable providers, models, and system prompts. The extension supports flexible multi-provider setups, model switching, custom prompts, direct insertion of code/images/documents into the chat, and tailored user interface with extensibility in mind.

    ---

    # Project Directory Tree

    ```
    .
    ├── CHANGELOG.md
    ├── current_settings
    │   ├── prompts.json
    │   └── providers.json
    ├── diegoaacchatgpt-1.1.0.vsix
    ├── dist
    │   ├── extension.js
    │   ├── extension.js.LICENSE.txt
    │   └── extension.js.map
    ├── examples
    │   ├── create.png
    │   ├── explain.png
    │   ├── main.png
    │   └── refactor.png
    ├── media
    │   ├── main.js
    │   ├── scripts
    │   │   ├── microlight.min.js
    │   │   ├── showdown.min.js
    │   │   └── tailwind.min.js
    │   └── styles.css
    ├── package-lock.json
    ├── package.json
    ├── README.md
    ├── resources
    │   ├── buy-default-yellow-small.png
    │   ├── extensionIcon.png
    │   └── icon.png
    ├── src
    │   ├── chatGptViewProvider.ts
    │   ├── extension.ts
    │   └── types.ts
    ├── toGenerateXSIX.txt
    ├── tsconfig.json
    ├── vsc-extension-quickstart.md
    ├── webpack.config.js
    └── yarn.lock
    ```

    ---

    # File-by-File Explanation

    ### 1. Extension Core Logic

    #### `src/extension.ts`
    - **Role**: The entry point for the VS Code extension, responsible for activation, registering commands, initializing provider/prompt configurations, and managing their updates.
    - **Modification Points**:
      - Introduce new commands to the command palette.
      - Change activation logic or initial provider/model selection heuristics.
      - Extend configuration listeners for new settings.
      - Integrate additional commands for chat actions or new features.

    #### `src/chatGptViewProvider.ts`
    - **Role**: UI and logic controller for the ChatGPT webview. Manages conversation state, tokenization, messages, prompt generation, webview communications, image/file handlers, chat updating, and interfaces with the OpenAI API (or similar) through selected providers.
    - **Modification Points**:
      - Adjust message-handling logic for new chat message types.
      - Extend/add webview message handlers for more interactivity.
      - Implement support for additional input (voice, etc.), rich content, or output formats.
      - Alter how provider/model switching updates state.
      - Modify or extend system prompts, token counting, stream interaction, or error handling.

    #### `src/types.ts`
    - **Role**: Provides all core TypeScript type definitions and interfaces for providers, models, prompts, messages, settings, etc. It is critical for type safety across extension logic.
    - **Modification Points**:
      - Add new provider/model/prompt fields as needed.
      - Extend `Message` types for richer content support (file, video, etc.).
      - Change options typing when adding new configurable behavior.

    ### 2. VS Code Extension Assembly

    #### `package.json`
    - **Role**: Extension manifest. Declares commands, menus, configuration schema, extension entry points, dependencies, and metadata.
    - **Modification Points**:
      - Add/remove VS Code commands and their palette or context menu entries.
      - Extend configuration schema for additional settings.
      - Adjust scripts, dependencies, or update VS Code compatibility.

    #### `webpack.config.js`
    - **Role**: Build configuration for using webpack to compile/pack the extension TypeScript into distributable JS.
    - **Modification Points**:
      - Add external libraries/modules or custom build steps.
      - Change output settings for new bundling targets.

    #### `tsconfig.json`
    - **Role**: TSC configuration. Sets the TypeScript compiler options relevant for strict type safety and VS Code/node.js targeting.
    - **Modification Points**:
      - Adjust strictness or output targets as needed.

    ### 3. Settings (User/Workspace) and Current Provider/Prompt Data

    #### `current_settings/prompts.json`
    - **Role**: Stores a set of system prompts with names that populate prompt selectors and define the conversation system context.
    - **Modification Points**:
      - Add/remove/edit prompt templates for different assistant behaviors.

    #### `current_settings/providers.json`
    - **Role**: Defines providers (OpenAI, Gemini, etc.), their API URLs, keys, and associated models/options, driving the provider/model selector lists.
    - **Modification Points**:
      - Add new provider or model entries, adjust options (e.g., temperature).

    ### 4. Webview UI/Frontend

    #### `media/main.js`
    - **Role**: Browser JS for the webview panel. Handles state (selected provider/model/prompt), input event listeners, message passing with VS Code backend, rendering of chat response, code block handling, and UI interactions.
    - **Modification Points**:
      - Add new interactive UI elements or input modes (e.g., sliders, toggles).
      - Change event handling (keybinds, drag-and-drop, etc.).
      - Extend webview messaging for new actions.

    #### `media/styles.css`
    - **Role**: Style definitions for the chat webview, selectors, and other UI components. Supports variable overrides for VS Code theming.
    - **Modification Points**:
      - Adjust/extend UI appearance for new widgets, dark/light mode, accessibility.

    ### 5. Static/Other

    #### `examples/`, `resources/`
    - **Role**: Image resources for UI icons, extension branding, and documentation.
    - **Modification Points**: Mostly for branding or illustrative updates.

    ---

    # Important Design Notes for Modification

    - **Provider/Model Extensibility**: Providers, their endpoints, and supported models are managed via JSON (`current_settings/providers.json`) and reflected in select menus via dynamic webview events. To support new LLM providers, extend this JSON and ensure backend logic is compatible with their protocols.
    - **Prompt Extensibility**: Prompts are decoupled and stored externally, loaded and updatable at runtime, supporting a broad range of "agent personas."
    - **Command Palette Integration**: New features or queries should be attached to commands in `package.json` and registered in `src/extension.ts`.
    - **UI Decoupling**: The webview frontend is isolated from the extension host — communication is only via message passing (`vscode.postMessage`). Adding UI controls or changing layout requires updates in both `media/main.js` and `src/chatGptViewProvider.ts`.
    - **Chat State Management**: All conversation state (including messages, system prompts, and selection) is managed centrally in `ChatGPTViewProvider`. Any changes to conversation persistence or replay should be localized here.
    - **Typing and API Evolvability**: All APIs between the backend/frontend must use the type definitions in `src/types.ts`; update these types to ensure cross-cutting integrity when extending formats or protocols.

    ---

    # Security Considerations

    - **Provider API Keys**: Stored in the `current_settings/providers.json` and may be embedded in extension settings (and potentially exposed through configuration). Never log, print, or expose API keys in UI elements or webview context.
    - **Webview Security**: Only trusted URIs/scripts/stylesheets are loaded into the webview via explicit resource URIs. No remote content is fetched in the webview context.
    - **Injection Risks**: User and model content is sanitized by markdown/Showdown; however, review any processing pipeline for risks of XSS, especially if new message types or HTML features are introduced.
    - **Configuration Update Hooks**: Avoid leaking sensitive info or allowing any settings injection into command invocation logic.
    - **File and Image Attachments**: Uploaded images/files are read as base64 and never written to disk, but always ensure no arbitrary code execution can arise from these interfaces.
    - **Command Registration**: Commands are only contextually active (e.g., if editor/text/resource selected).

    ---

    # Summary Table of Extensible Components

    | Location/Module                        | Purpose/Extension Point                                | What Can Safely Be Modified                                                              |
    |----------------------------------------|-------------------------------------------------------|------------------------------------------------------------------------------------------|
    | `src/extension.ts`                     | Extension entry/activation/commands                   | Add new commands, extend activation, modify providers/prompts initialization             |
    | `src/chatGptViewProvider.ts`           | Chat logic, provider and prompt management, UI bridge | Change message handling, add webview events, modify chat rendering/pipelines             |
    | `src/types.ts`                         | Data types for providers, prompts, chat, settings     | Extend types/interfaces for new models, message fields, configurations                   |
    | `media/main.js`                        | Webview JS (UI logic and events)                      | Add UI controls, event handlers, update message-passing logic, change rendering details  |
    | `media/styles.css`                     | Webview UI styles and theming                         | Modify/expand CSS, support contrast/themes, additional UI elements                       |
    | `package.json`                         | VS Code manifest/commands/contributes                 | Add/remove commands, extend configuration schema, metadata                               |
    | `webpack.config.js`, `tsconfig.json`   | Build and compilation configuration                   | Add loaders, tweak output, build target, source maps, or strictness settings             |
    | `current_settings/providers.json`      | Provider/model configuration                          | Add providers/models/options as needed                                                   |
    | `current_settings/prompts.json`        | System prompt configuration                           | Add/modify/remove prompts, adjust default behaviors                                      |

    ---

    # Final Notes

    - **Follow the architectural separation**: UI logic (`media/`), extension/backend logic (`src/`), configurations, and assets remain organized and decoupled.
    - **TypeScript strictness**: Strong type-checking is enabled and should not be relaxed unless absolutely necessary for new types; prefer updating `src/types.ts` as needed.
    - **Always update both backend and frontend**: Any new UX/UI feature added to the webview (`media/`) often requires corresponding backend adjustments in `chatGptViewProvider.ts`.
    - **Testing/Debugging**: Use the `dist/` outputs for testing in VS Code; touch production code through TypeScript (`src/`) and apply webpack for builds.
    - **Sensitive Data**: Never leak API keys or user data in logs, UIs, or via messages passing to the webview.
    - **Extending Providers/Models**: All logic for provider switching, system prompt changes, and model-specific options (like temperature, token limits, etc.) is dynamic and should use the type-safe definitions and ensure new items appear in both configuration and the UI selectors.
    - **Safe Defaults**: If adding new features, prefer opt-in configuration, keep the user in control of new behaviors (via settings).
    - **Future-proofing**: Consider versioning settings and exported configs for forward-compatibility when introducing breaking changes.

    ---

    This documentation provides a modification and extension-oriented view of the project structure, logic, and conventions, focusing on safe, programmatic adaptability for an AI agent or future developer workflows.
  selected: true
