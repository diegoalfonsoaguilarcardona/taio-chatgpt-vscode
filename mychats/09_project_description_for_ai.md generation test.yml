- role: system
  content: |-
    Generate a `project_description_for_ai.md` file to describe the project you are working on.
    Begin by requesting the project directory tree from the user.
    Determine which files are significant for understanding and modifying the project. Request these files from the user.
    Review the content of the files provided. If further information is required to understand the project, request additional files.
    Once sufficient information is gathered, create the `project_description_for_ai.md` file containing the following sections: Project Overview, Project Directory Tree, File-by-File Explanation, Important Design Notes for Modification, Security Considerations, Summary Table of Main Extensible or Important Areas, and Final Notes.
    # Steps
    1. **Request Project Tree**: Ask the user to provide the project directory tree.
    2. **Identify Important Files**: Determine which files are key to understanding and modifying the project, and request them from the user.
    3. **Review and Request Additional Files**: Examine provided files for comprehension and request any additional files if more information is necessary.
    4. **Compile Information**: Gather all necessary information to form a comprehensive understanding of the project.
    5. **Generate Project Description File**: Create `project_description_for_ai.md` with the required sections.
    # Output Format
    The output should be a markdown file structured as follows:
    1. **Project Overview**: Brief description of the project’s purpose.
    2. **Project Directory Tree**: Visual representation of the project files and folders.
    3. **File-by-File Explanation**: Detailed explanation of each significant file, organized by folder.
    4. **Important Design Notes for Modification**: Key design elements for modification.
    5. **Security Considerations**: Security elements and considerations.
    6. **Summary Table**: Main extensible or important areas of the project.
    7. **Final Notes**: Additional relevant observations or notes.
    # Notes
    - Ensure each section is clear and concise.
    - Include any technical language or terminologies specific to the project context.
    - Address security considerations explicitly to identify potential risks or vulnerabilities.
  selected: true
- role: user
  content: Hello
  selected: true
- role: assistant
  content: |-
    Hello! To get started on generating your project description, could you please provide the project directory tree? This will help me identify the key files and structure of your project. You can use a tool like tree or manually list the folders and files. Example:

    my_project/
    ├── src/
    │   ├── main.py
    │   └── helper.py
    ├── requirements.txt
    ├── README.md
    └── config.yaml

    Once you provide the directory tree, I’ll identify important files to review next.
  selected: true
- role: user
  content: |-
    This is my tree
    ```ini
    .
    ├── CHANGELOG.md
    ├── diegoaacchatgpt-1.1.0.vsix
    ├── dist
    │   ├── extension.js
    │   ├── extension.js.LICENSE.txt
    │   └── extension.js.map
    ├── examples
    │   ├── create.png
    │   ├── explain.png
    │   ├── main.png
    │   └── refactor.png
    ├── media
    │   ├── main.js
    │   ├── scripts
    │   │   ├── microlight.min.js
    │   │   ├── showdown.min.js
    │   │   └── tailwind.min.js
    │   └── styles.css
    ├── package-lock.json
    ├── package.json
    ├── README.md
    ├── resources
    │   ├── buy-default-yellow-small.png
    │   ├── extensionIcon.png
    │   └── icon.png
    ├── src
    │   ├── chatGptViewProvider.ts
    │   ├── extension.ts
    │   └── types.ts
    ├── toGenerateXSIX.txt
    ├── tsconfig.json
    ├── vsc-extension-quickstart.md
    ├── webpack.config.js
    └── yarn.lock
    ```
  selected: true
- role: assistant
  content: |-
    Thank you for providing the directory tree! To create a meaningful and useful project description, I'll need to review the core source code and configuration files. Based on your project's structure, could you please provide the contents of the following significant files:

    1. **package.json** – Essential for project metadata, dependencies, and scripts.
    2. **src/extension.ts** – Likely the main entry point for your extension.
    3. **src/chatGptViewProvider.ts** – Presumably contains important provider logic.
    4. **src/types.ts** – Useful for understanding types used across the codebase.
    5. **README.md** – Usually contains purpose, usage, and context for the project.
    6. **webpack.config.js** – If applicable, for build and bundling insights.
    7. **tsconfig.json** – Provides information about TypeScript configuration.

    Please upload the content of these files (or as many as you can in one message). Once I've reviewed them, I’ll let you know if any additional files are necessary before generating the comprehensive project description!
  selected: true
- role: user
  content: |-
    **package.json**
    ```json
    {
      "name": "diegoaacchatgpt",
      "displayName": "ChatGPT for Visual Studio Code: write and improve code using AI",
      "description": "Use ChatGPT and GPT4 right inside the IDE to enhance and automate your coding with AI-powered assistance (unofficial)",
      "version": "1.1.0",
      "publisher": "diegoaac",
      "icon": "resources/extensionIcon.png",
      "license": "MIT",
      "repository": {
        "url": "https://github.com/timkmecl/chatgpt-vscode"
      },
      "engines": {
        "vscode": "^1.73.0"
      },
      "categories": [
        "Other"
      ],
      "keywords": [
        "chatgpt",
        "openai",
        "gpt3",
        "gpt4",
        "copilot",
        "ai",
        "explain",
        "find bugs",
        "explain ",
        "refactor"
      ],
      "activationEvents": [
        "onView:chatgpt.chatView",
        "onCommand:chatgpt.ask",
        "onCommand:chatgpt.explain",
        "onCommand:chatgpt.refactor",
        "onCommand:chatgpt.optimize",
        "onCommand:chatgpt.findProblems",
        "onCommand:chatgpt.documentation",
        "onCommand:chatgpt.useSelectionAsChat"
      ],
      "main": "./dist/extension.js",
      "contributes": {
        "commands": [
          {
            "command": "chatgpt.ask",
            "title": "Ask ChatGPT"
          },
          {
            "command": "chatgpt.explain",
            "title": "ChatGPT: Explain selection"
          },
          {
            "command": "chatgpt.refactor",
            "title": "ChatGPT: Refactor selection"
          },
          {
            "command": "chatgpt.findProblems",
            "title": "ChatGPT: Find problems"
          },
          {
            "command": "chatgpt.optimize",
            "title": "ChatGPT: Optimize selection"
          },
          {
            "command": "chatgpt.documentation",
            "title": "ChatGPT: Write documentation"
          },
          {
            "command": "chatgpt.resetConversation",
            "title": "Reset ChatGPT conversation"
          },
          {
            "command": "chatgpt.pasteChat",
            "title": "Paste ChatGPT chat"
          },
          {
            "command": "chatgpt.useSelectionAsChat",
            "title": "Use selection as ChatGPT conversation"
          },
          {
            "command": "chatgpt.tryAgain",
            "title": "Retry ChatGPT request"
          },
          {
            "command": "chatgpt.addImageToChat",
            "title": "Add Image to ChatGPT"
          },
          {
            "command": "chatgpt.addFileToChat",
            "title": "Add File Content to ChatGPT"
          }
        ],
        "menus": {
          "editor/context": [
            {
              "command": "chatgpt.ask",
              "when": "editorTextFocus",
              "group": "chatgpt-menu-group@1"
            },
            {
              "command": "chatgpt.explain",
              "when": "editorHasSelection",
              "group": "chatgpt-menu-group@2"
            },
            {
              "command": "chatgpt.refactor",
              "when": "editorHasSelection",
              "group": "chatgpt-menu-group@3"
            },
            {
              "command": "chatgpt.findProblems",
              "when": "editorHasSelection",
              "group": "chatgpt-menu-group@4"
            },
            {
              "command": "chatgpt.optimize",
              "when": "editorHasSelection",
              "group": "chatgpt-menu-group@5"
            },
            {
              "command": "chatgpt.documentation",
              "when": "editorHasSelection",
              "group": "chatgpt-menu-group@6"
            },
            {
              "command": "chatgpt.useSelectionAsChat",
              "when": "editorHasSelection",
              "group": "chatgpt-menu-group@7"
            }
          ],
          "commandPalette": [
            {
              "command": "chatgpt.ask"
            },
            {
              "command": "chatgpt.explain",
              "when": "editorHasSelection"
            },
            {
              "command": "chatgpt.refactor",
              "when": "editorHasSelection"
            },
            {
              "command": "chatgpt.findProblems",
              "when": "editorHasSelection"
            },
            {
              "command": "chatgpt.optimize",
              "when": "editorHasSelection"
            },
            {
              "command": "chatgpt.documentation",
              "when": "editorHasSelection"
            },
            {
              "command": "chatgpt.resetConversation"
            },
            {
              "command": "chatgpt.pasteChat"
            },
            {
              "command": "chatgpt.useSelectionAsChat",
              "when": "editorHasSelection"
            }
          ],
          "explorer/context": [
            {
              "command": "chatgpt.addImageToChat",
              "when": "resourceExtname == .png || resourceExtname == .jpg || resourceExtname == .jpeg || resourceExtname == .gif",
              "group": "navigation"
            },
            {
              "command": "chatgpt.addFileToChat",
              "when": "resourceLangId =~ /^((javascript)|(typescript)|(python)|(json)|(markdown)|(plaintext)|(cpp)|(c)|(java)|(xml)|(html)|(css)|(shellscript)|(yaml)|(toml)|(ini)|(go)|(ruby)|(php)|(rust)|(csharp)|(plaintext))$/",
              "group": "navigation"
            }
          ]
        },
        "viewsContainers": {
          "activitybar": [
            {
              "id": "chatgpt",
              "title": "ChatGPT",
              "icon": "resources/icon.png"
            }
          ]
        },
        "views": {
          "chatgpt": [
            {
              "type": "webview",
              "id": "chatgpt.chatView",
              "name": "ChatGPT"
            }
          ]
        },
        "configuration": {
          "title": "chatGPT",
          "type": "object",
          "properties": {
            "chatgpt.providers": {
              "type": "array",
              "description": "List of AI providers with their configurations.",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the provider (e.g., OpenAI, CustomAPI)."
                  },
                  "apiKey": {
                    "type": "string",
                    "description": "API key for the provider."
                  },
                  "apiUrl": {
                    "type": "string",
                    "description": "API URL for the provider."
                  },
                  "models": {
                    "type": "array",
                    "description": "List of models offered by this provider.",
                    "items": {
                      "type": "object",
                      "properties": {
                        "name": {
                          "type": "string",
                          "description": "Name of the model (e.g., gpt-3.5-turbo)."
                        },
                        "options": {
                          "type": "object",
                          "description": "Options for the model.",
                          "additionalProperties": {
                            "type": "any",
                            "description": "Custom option key-value pairs for the model."
                          }
                        }
                      },
                      "required": ["name"]
                    }
                  }
                },
                "required": ["name", "apiKey", "apiUrl", "models"]
              },
              "order": 1
            },
            "chatgpt.prompts" : {
              "type":"array",
              "description": "List of possible prompts to use",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the prompt (e.g., ChainOfThougt, Simple Engenier)."
                  },
                  "prompt": {
                    "type": "string",
                    "description": "The prompt it self"
                  }
                },
                "required": ["name", "prompt"]
              },
              "order": 2
            },
            "chatgpt.pasteOnClick": {
              "type": "boolean",
              "default": true,
              "description": "Paste the code from a codeblock inside the response into the editor when you click on it",
              "order": 3
            },
            "chatgpt.promptPrefix.explain": {
              "type": "string",
              "default": "Explain what this code does: ",
              "description": "The prompt prefix used for explaining the selected code",
              "order": 4
            },
            "chatgpt.promptPrefix.refactor": {
              "type": "string",
              "default": "Refactor this code and explain what's changed: ",
              "description": "The prompt prefix used for refactoring the selected code",
              "order": 5
            },
            "chatgpt.promptPrefix.findProblems": {
              "type": "string",
              "default": "Find problems with the following code, fix them and explain what was wrong (Do not change anything else, if there are no problems say so): ",
              "description": "The prompt prefix used for finding problems in the selected code",
              "order": 6
            },
            "chatgpt.promptPrefix.documentation": {
              "type": "string",
              "default": "Write documentation for the following code: ",
              "description": "The prompt prefix used for writing documentation for the selected code",
              "order": 7
            },
            "chatgpt.promptPrefix.optimize": {
              "type": "string",
              "default": "Optimize the following code if there is anything to improve, if not say so: ",
              "description": "The prompt prefix used for optimizing the selected code",
              "order": 8
            },
            "chatgpt.keepConversation": {
              "type": "boolean",
              "default": true,
              "description": "Keep the conversation going by using the same conversation ID for all requests (allows follow-up questions)",
              "order": 9
            },
            "chatgpt.timeoutLength": {
              "type": "number",
              "default": "120",
              "description": "How long should the request wait for a response before timing out (in seconds)",
              "order": 10
            },
            "chatgpt.selectedInsideCodeblock": {
              "type": "boolean",
              "default": true,
              "description": "Append selected code as a codeblock (```...code...```) instead of plain text",
              "order": 11
            },
            "chatgpt.codeblockWithLanguageId": {
              "type": "boolean",
              "default": true,
              "description": "Append language id of the selected code to the codeblock (```language...code...```)",
              "order": 12
            }
          }
        }
      },
      "scripts": {
        "vscode:prepublish": "yarn run package",
        "compile": "webpack",
        "watch": "webpack --watch",
        "package": "webpack --mode production --devtool hidden-source-map",
        "compile-tests": "tsc -p . --outDir out",
        "watch-tests": "tsc -p . -w --outDir out",
        "pretest": "yarn run compile-tests && yarn run compile && yarn run lint",
        "lint": "eslint src --ext ts",
        "test": "node ./out/test/runTest.js",
        "update-package-lock": "npm install --package-lock-only"
      },
      "devDependencies": {
        "@types/glob": "^8.0.0",
        "@types/js-yaml": "^4.0.9",
        "@types/mocha": "^10.0.1",
        "@types/node": "16.x",
        "@types/vscode": "^1.73.0",
        "@typescript-eslint/eslint-plugin": "^5.45.0",
        "@typescript-eslint/parser": "^5.45.0",
        "@vscode/test-electron": "^2.2.0",
        "eslint": "^8.28.0",
        "glob": "^8.0.3",
        "mocha": "^10.1.0",
        "ts-loader": "^9.4.1",
        "typescript": "^4.9.3",
        "webpack": "^5.75.0",
        "webpack-cli": "^5.0.0"
      },
      "dependencies": {
        "@types/node-fetch": "^2.6.11",
        "js-tiktoken": "^1.0.10",
        "js-yaml": "^4.1.0",
        "node-fetch": "^3.3.2",
        "openai": "^4.29.2"
      }
    }

    ```
  selected: true
- role: user
  content: "**src/chatGptViewProvider.ts**\n```ts\nimport * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport * as yaml from 'js-yaml';\nimport OpenAI from \"openai\";\nimport { encodingForModel } from \"js-tiktoken\";\nimport { AuthInfo, Settings, Message, Provider, Prompt, UserMessage, BASE_URL } from './types';\nimport { ChatCompletionContentPart, ChatCompletionContentPartImage, ChatCompletionContentPartText } from 'openai/resources/chat/completions';\n\nexport class ChatGPTViewProvider implements vscode.WebviewViewProvider {\n  public static readonly viewType = 'chatgpt.chatView';\n  private _view?: vscode.WebviewView;\n\n  private _conversation?: any;\n  private _messages?: Message[];\n  private _openai?: OpenAI;\n\n  private _response?: string;\n  private _totalNumberOfTokens?: number;\n  private _prompt?: string;\n  private _fullPrompt?: string;\n  private _currentMessageNumber = 0;\n  private _enc = encodingForModel(\"gpt-4\"); //Hardcoded for now\n\n  private _settings: Settings = {\n    selectedInsideCodeblock: false,\n    codeblockWithLanguageId: false,\n    pasteOnClick: true,\n    keepConversation: true,\n    timeoutLength: 60,\n    apiUrl: BASE_URL,\n    model: 'gpt-3.5-turbo',\n    options: {\n    },\n  };\n  private _authInfo?: AuthInfo;\n\n  // In the constructor, we store the URI of the extension\n  constructor(private readonly _extensionUri: vscode.Uri) {\n    this._messages = [];\n    this._messages?.push({ role: \"system\", content: this.getStartSystemPrompt(), selected:true });\n    console.log(\"constructor....\");\n    console.log(\"messages:\", this._messages);\n  }\n\n  // Set the API key and create a new API instance based on this key\n  public setAuthenticationInfo(authInfo: AuthInfo) {\n    this._authInfo = authInfo;\n    this._newAPI();\n  }\n\n  public setSettings(settings: Settings) {\n    let changeModel = false;\n  \n    // Check if there are any keys in the options object of the settings\n    if (settings.apiUrl || settings.model || (settings.options && Object.keys(settings.options).length > 0)) {\n      changeModel = true;\n    }\n  \n    // Update settings with the new values\n    this._settings = { ...this._settings, ...settings };\n  \n    if (changeModel) {\n      //this._newAPI();\n    }\n  }\n\n  public getSettings() {\n    return this._settings;\n  }\n\n  // This private method initializes a new ChatGPTAPI instance\n  private _newAPI() {\n    console.log(\"New API\");\n    console.log(\"Messages:\", this._messages);\n    if (!this._authInfo || !this._settings?.apiUrl) {\n      console.warn(\"API key or API URL not set, please go to extension settings (read README.md for more info)\");\n    } else {\n      console.log(\"apiUrl:\", this._settings?.apiUrl);\n      this._openai = new OpenAI(\n        {\n          apiKey: this._authInfo?.apiKey,\n          baseURL: this._authInfo?.apiUrl\n        }\n      );\n    }\n    setTimeout(() => {\n      const chat_response = this._updateChatMessages(\n        this._getMessagesNumberOfTokens(),\n        0\n      );\n      this._view?.webview.postMessage({ type: 'addResponse', value: chat_response });\n    }, 2000);\n  }\n\n  public resolveWebviewView(\n    webviewView: vscode.WebviewView,\n    context: vscode.WebviewViewResolveContext,\n    _token: vscode.CancellationToken,\n  ) {\n    this._view = webviewView;\n\n    // set options for the webview, allow scripts\n    webviewView.webview.options = {\n      enableScripts: true,\n      localResourceRoots: [\n        this._extensionUri\n      ]\n    };\n\n    // set the HTML for the webview\n    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);\n\n    // add an event listener for messages received by the webview\n    webviewView.webview.onDidReceiveMessage(async data =>  {\n      switch (data.type) {\n        case 'ready':\n          {\n            const config = vscode.workspace.getConfiguration('chatgpt');\n            let providers: Provider[] = config.get('providers') || [];\n            let prompts: Prompt[] = config.get('prompts') || [];\n            this.set_providers(providers);\n            this.set_prompts(prompts);\n            break;\n          }\n        case 'codeSelected':\n          {\n            // do nothing if the pasteOnClick option is disabled\n            if (!this._settings.pasteOnClick) {\n              break;\n            }\n            let code = data.value;\n            const snippet = new vscode.SnippetString();\n            snippet.appendText(code);\n            // insert the code as a snippet into the active text editor\n            vscode.window.activeTextEditor?.insertSnippet(snippet);\n            break;\n          }\n        case 'pasteImage': \n          {\n            const base64Data = data.value;\n            const imageType = base64Data.substring(base64Data.indexOf(':') + 1, base64Data.indexOf(';'));\n            const fileType = imageType.split('/')[1];\n            const fileName = `clipboard_image.${fileType}`;\n            this.addImageToChat(base64Data, fileName);\n            break;\n          }\n        case 'prompt':\n          {\n            console.log(\"prompt\");\n            this.search(data.value);\n            break;\n          }\n        case 'promptNoQuery':\n          {\n            console.log(\"promptNoQuery\");\n\n            let searchPrompt = await this._generate_search_prompt(data.value);\n            \n            this._messages?.push({ role: \"user\", content: searchPrompt, selected:true })\n            let chat_response = this._updateChatMessages(\n              this._getMessagesNumberOfTokens(),\n              0\n            );\n            this._response = chat_response;\n            this._view?.webview.postMessage({ type: 'addResponse', value: chat_response });\n            break;\n          }\n        case 'checkboxChanged':\n          {\n            console.log(\"checkboxChanged:\", data);\n            const idParts = data.id.split('-'); // Split the id into parts\n            if(idParts.length === 3) {\n              const indexStr = idParts[2]; // Grab the last part, which should contain the index\n              const index = parseInt(indexStr, 10); // Convert the index to an integer and adjust if necessary\n            \n              if(this._messages && index >= 0 && index < this._messages.length) {\n                // If the index is within the bounds of the array, update the checked status\n                this._messages[index].selected = data.checked;\n              } else {\n                // Handle cases where index is out of bounds or _messages is not an array\n                console.error('Index is out of bounds or _messages is not properly defined.');\n              }\n            } else {\n              // Handle cases where data.id does not follow the expected format\n              console.error('data.id is not in the expected format.');\n            }\n            break;\n          }\n        case 'messageContentChanged':\n          {\n            console.log(\"messageContentChanged:\", data);\n            const idParts = data.id.split('-'); // Split the id into parts\n            if(idParts.length === 3) {\n              const indexStr = idParts[2]; // Grab the last part, which should contain the index\n              const index = parseInt(indexStr, 10); // Convert the index to an integer and adjust if necessary\n            \n              if(this._messages && index >= 0 && index < this._messages.length) {\n                // If the index is within the bounds of the array, update the checked status\n                this._messages[index].content = data.value;\n              } else {\n                // Handle cases where index is out of bounds or _messages is not an array\n                console.error('Index is out of bounds or _messages is not properly defined.');\n              }\n            } else {\n              // Handle cases where data.id does not follow the expected format\n              console.error('data.id is not in the expected format.');\n            }\n            console.log(\"messages:\", this._messages);\n            break;\n          }\n        case \"providerModelChanged\":\n          {\n            const providerIndex = data.providerIndex;\n            const modelIndex = data.modelIndex;\n            console.log(\"Provider Changed, providerIndex:\", providerIndex, \", model:\", modelIndex);\n\n            const config = vscode.workspace.getConfiguration('chatgpt');\n            let providers: Provider[] = config.get('providers') || [];\n      \n            if (providers && providers.length > providerIndex) {\n              const provider_data = providers[providerIndex];\n              if (provider_data.models && provider_data.models.length > modelIndex) {\n                const model_data = provider_data.models[modelIndex];\n                const provider_settings = {\n                  model: model_data.name,\n                  apiUrl: provider_data.apiUrl,\n                  apiKey: provider_data.apiKey,\n                  options: {\n                  ...model_data.options // assuming model_data contains options and it includes maxModelTokens, maxResponseTokens, and temperature\n                  },\n                };\n                this.setSettings({\n                  apiUrl: provider_settings.apiUrl,\n                  model: provider_settings.model,\n                  options: {\n                  ...provider_settings.options, // Spread operator to include all keys from options\n                  },\n                });\n                // Put configuration settings into the provider\n                this.setAuthenticationInfo({\n                  apiKey: provider_settings.apiKey,\n                  apiUrl: provider_settings.apiUrl\n                });\n              }\t\t\t\t\t\t\n            }\n            break;\n          }\n        case \"systemPromptChanged\":\n          {\n            const systemPromptIndex = data.systemPromptIndex;\n            console.log(\"systemPrompt Changed, providerIndex:\", systemPromptIndex);\n\n            const config = vscode.workspace.getConfiguration('chatgpt');\n            let prompts: Prompt[] = config.get('prompts') || [];\n      \n            if (prompts && prompts.length > systemPromptIndex) {\n              const prompt_data = prompts[systemPromptIndex];\n              if (prompt_data.name && prompt_data.prompt) {\n                this.set_prompt(prompt_data);\n              }\t\t\t\t\t\t\n            }\n            break;\n          }\n      }\n    });\n  }\n\n  public getStartSystemPrompt() {\n    const config = vscode.workspace.getConfiguration('chatgpt');\n    let prompts: Prompt[] = config.get('prompts') || [];\n    let start_system_prompt = \"You are a helpful assistant.\";\n    if (prompts && prompts.length > 0) {\n      const prompt_data = prompts[0];\n      if (prompt_data.name && prompt_data.prompt) {\n        start_system_prompt = prompt_data.prompt;\n      }\t\t\t\t\t\t\n    }\n    return start_system_prompt;\n  }\n\n\n  public async resetConversation() {\n    console.log(this, this._conversation);\n    if (this._conversation) {\n      this._conversation = null;\n    }\n    this._prompt = '';\n    this._response = '';\n    this._fullPrompt = '';\n    this._totalNumberOfTokens = 0;\n    this._view?.webview.postMessage({ type: 'setPrompt', value: '' });\n    this._messages = [];\n    \n    this._messages?.push({ role: \"system\", content: this.getStartSystemPrompt(), selected:true });\n    const chat_response = this._updateChatMessages(\n      this._getMessagesNumberOfTokens(),\n      0\n    );\n    this._view?.webview.postMessage({ type: 'addResponse', value: chat_response });\n  }\n\n  public async pasteChat() {\n    console.log(\"pasteChat\");\n  \n    // Ensure there is an active text editor where we can paste the YAML\n    if (!vscode.window.activeTextEditor) {\n      vscode.window.showErrorMessage('No active text editor!');\n      return;\n    }\n  \n    try {\n      // Get the original _messages object\n      // If you want to exclude any other properties from the YAML, you can map and remove them here\n      const messagesForYaml = this._messages?.map(({ role, content, selected }) => ({\n        role, content, selected\n      }));\n  \n      // Convert messages to a YAML string\n      const messagesYaml = yaml.dump(messagesForYaml, { noRefs: true, lineWidth: -1 });\n  \n      // Create a new snippet and append the YAML string\n      const snippet = new vscode.SnippetString();\n      snippet.appendText(messagesYaml);\n  \n      // Insert the snippet into the active text editor\n      await vscode.window.activeTextEditor.insertSnippet(snippet);\n  \n      console.log(\"Chat pasted as YAML successfully.\");\n    } catch (error) {\n      console.error(\"Failed to paste chat as YAML:\", error);\n      vscode.window.showErrorMessage('Failed to paste chat as YAML: ' + error);\n    }\n  }\n  \n  public async useSelectionAsChat() {\n    console.log(\"use selection as chat\");\n\n    // Ensure there is an active text editor with a selection\n    const activeEditor = vscode.window.activeTextEditor;\n    if (!activeEditor) {\n      vscode.window.showErrorMessage('No active text editor with a selection!');\n      return;\n    }\n\n    const selection = activeEditor.selection;\n    if (selection.isEmpty) {\n      vscode.window.showErrorMessage('No text selected!');\n      return;\n    }\n\n    // Get the selected text\n    const selectedText = activeEditor.document.getText(selection);\n\n    try {\n      // Parse the selected text as YAML\n      const parsedMessages = yaml.load(selectedText);\n\n      // Validate the parsed YAML structure\n      if (!Array.isArray(parsedMessages)) {\n        throw new Error('Selected text is not an array of messages.');\n      }\n\n      // Validation of each message in the array\n      for (const msg of parsedMessages) {\n        if (typeof msg !== 'object' || !('role' in msg) || !('content' in msg) || !('selected' in msg)) {\n          throw new Error('Invalid message format. Each message must have role, content, and selected properties.');\n        }\n      }\n\n      // If valid, update the _messages array with new data\n      this._messages = parsedMessages;\n\n      // Update the webview visualization\n      const chat_response = this._updateChatMessages(\n        this._getMessagesNumberOfTokens(),\n        0\n      );\n      this._view?.webview.postMessage({ type: 'addResponse', value: chat_response });\n\n      console.log(\"Updated messages from selection successfully.\");\n    } catch (error) {\n      console.error(\"Failed to use selection as chat:\", error);\n      vscode.window.showErrorMessage('Failed to use selection as chat: ' + error);\n    }\n  }\n\n  public fixCodeBlocks(response: string) {\n    // Use a regular expression to find all occurrences of the substring in the string\n    const REGEX_CODEBLOCK = new RegExp('\\`\\`\\`', 'g');\n    const matches = response.match(REGEX_CODEBLOCK);\n\n    // Return the number of occurrences of the substring in the response, check if even\n    const count = matches ? matches.length : 0;\n    if (count % 2 === 0) {\n      return response;\n    } else {\n      // else append ``` to the end to make the last code block complete\n      console.log(\"Warning - code block not complete\");\n      return response.concat('\\n\\`\\`\\`');\n    }\n\n  }\n\n  private _getMessagesNumberOfTokens() {\n    \n    let full_promt = \"\";\n    if (this._messages) {\n      for (const message of this._messages) {\n        if (message.selected) {\n          full_promt += \"\\n# <u>\" + message.role.toUpperCase() + \"</u>:\\n\" + message.content;\n        }\n      }\n    }\n\n    const tokenList = this._enc.encode(full_promt);\n    return tokenList.length;\n  }\n\n\n  \n  public getSelectedMessagesWithoutSelectedProperty(): Omit<Message, 'selected'>[] {\n    let ret = this._messages?.filter(message => message.selected).map(({ role, content }) => ({\n    role, content\n    })) || [];\n    return ret;\n  }\n\n  private _containsCodeBlockOrListItems(content: string): boolean {\n    // Regex pattern to match code blocks.\n    const codeBlockPattern = /```[\\s\\S]*?```/;\n  \n    // Regex pattern to match bullet points or numbered list items.\n    const listItemPattern = /^(?:\\s*(?:[-*+]|\\d+\\.)\\s+.+)$/m;\n  \n    // Test if the content contains a code block or list items.\n    return codeBlockPattern.test(content) || listItemPattern.test(content);\n  }\n\n\n  private isChatCompletionContentPart(value: any): value is ChatCompletionContentPart {\n    return this.isChatCompletionContentPartImage(value);\n  }\n  \n    \n  private isChatCompletionContentPartText(value: any): value is ChatCompletionContentPartText {\n    return typeof value === 'object'\n      && value != null\n      && typeof value.text === 'string'\n      && value.type === 'text';\n  }\n  private isChatCompletionContentPartImage(value: any): value is ChatCompletionContentPartImage {\n    return typeof value === 'object'\n      && value !== null\n      && typeof value.image_url === 'object'\n      && typeof value.image_url.url === 'string'\n      && value.type === 'image_url';\n  }\n    \n  private _updateChatMessages(promtNumberOfTokens:number, completionTokens:number) {\n    let chat_response = \"\";\n    if (this._messages) {\n      this._messages.forEach((message, index) => {\n        const selected = message.selected;\n        const checked_string = selected ? \"checked\" : \"\";\n        if (typeof message.content === 'string') {\n          if (this._containsCodeBlockOrListItems(message.content)) {\n            chat_response += \"\\n# <u> <input id='message-checkbox-\" + index + \"' type='checkbox' \" + checked_string + \" onchange='myFunction(this)'> \" + message.role.toUpperCase() + \"</u>:\\n\" + message.content;\n          } else {\n            chat_response += \"\\n# <u> <input id='message-checkbox-\" + index + \"' type='checkbox' \" + checked_string + \" onchange='myFunction(this)'> \" + message.role.toUpperCase() + \"</u>: <div id='message-content-\" + index + \"' contenteditable='false' onclick='makeEditable(this)' onblur='saveContent(this)'>\"+ message.content + \"</div>\";\n          }\n        } else if (Array.isArray(message.content)) {\n          // Handle the case where message.content is an array of ChatCompletionContentPartImage\n          chat_response += \"\\n# <u> <input id='message-checkbox-\" + index + \"' type='checkbox' \" + checked_string + \" onchange='myFunction(this)'> \" + message.role.toUpperCase() + \"</u>: <div id='message-content-\" + index + \"' contenteditable='false'>\";\n          message.content.forEach(part => {\n            console.log(\"processing an object...\")\n            if (this.isChatCompletionContentPartImage(part)) {\n              console.log(\"Is an image!!!\")\n              // Process each ChatCompletionContentPartImage item\n              chat_response += \"<img src='\"+ part.image_url.url + \"' alt='Base64 Image'/>\";\n            }\n            if (this.isChatCompletionContentPartText(part)) {\n              console.log(\"Is a text!!!\")\n              chat_response += part.text;\n            }\n          });\n          chat_response += \"</div>\"\n        }\n      });\n    }\n    if (this._totalNumberOfTokens !== undefined) {\n      this._totalNumberOfTokens += promtNumberOfTokens + completionTokens;\n      chat_response += `\\n\\n---\\n*<sub>Total Tokens: ${this._totalNumberOfTokens},  Tokens used: ${promtNumberOfTokens + completionTokens} (${promtNumberOfTokens}+${completionTokens}), model: ${this._settings.model}</sub>* \\n\\n---\\n\\n\\n\\n\\n\\n\\n`;\n    }\n    return chat_response;\n  }\n  \n  private async _generate_search_prompt(prompt:string) {\n    this._prompt = prompt;\n    if (!prompt) {\n      prompt = '';\n    }\n\n    // Focus the ChatGPT view\n    if (!this._view) {\n      await vscode.commands.executeCommand('chatgpt.chatView.focus');\n    } else {\n      this._view?.show?.(true);\n    }\n\n    // Initialize response and token count\n    \n    if (!this._response) {\n      this._response = '';\n    }\n    if (!this._totalNumberOfTokens) {\n      this._totalNumberOfTokens = 0;\n    }\n\n    // Get selected text and language ID (if applicable)\n    const selection = vscode.window.activeTextEditor?.selection;\n    const selectedText = vscode.window.activeTextEditor?.document.getText(selection);\n    const languageId =\n      (this._settings.codeblockWithLanguageId\n        ? vscode.window.activeTextEditor?.document?.languageId\n        : undefined) || '';\n\n    // Build the search prompt\n    let searchPrompt = '';\n    if (selection && selectedText) {\n      if (this._settings.selectedInsideCodeblock) {\n        searchPrompt = `${prompt}\\n\\`\\`\\`${languageId}\\n${selectedText}\\n\\`\\`\\``;\n      } else {\n        searchPrompt = `${prompt}\\n${selectedText}\\n`;\n      }\n    } else {\n      searchPrompt = prompt;\n    }\n    this._fullPrompt = searchPrompt;\n\n    // Increment message number and store for tracking\n    this._currentMessageNumber++;\n    return searchPrompt;\n\n  }\n\n  public set_providers(providers: Provider[]): void {\n    this._view?.webview.postMessage({ type: 'initialize', value: providers });\n  }\n\n  public set_prompts(prompts: Prompt[]): void {\n    console.log(\"Set Prompts:\", prompts);\n    this._view?.webview.postMessage({ type: 'initialize_prompts', value: prompts });\n  }\n\n  public set_prompt(prompt: Prompt): void {\n    // Check if _messages is defined\n    if (this._messages) {\n      this._messages[0] = { role: \"system\", content: prompt.prompt, selected: true };\n    } else {\n      this._messages = [{ role: \"system\", content: prompt.prompt, selected: true }];\n    }\n    console.log(\"calling updateResponse\");\n    let chat_response = this._updateChatMessages(0, 0)\n\n    this._view?.webview.postMessage({ type: 'addResponse', value: chat_response });\n    this._view?.webview.postMessage({ type: 'setPrompt', value: '' });\n  }\n\n  public async search(prompt?: string) {\n    // Check if the API key and URL are set\n    if (!this._authInfo || !this._settings?.apiUrl) {\n      this._view?.webview.postMessage({\n        type: 'addResponse',\n        value: '[ERROR] \"API key or API URL not set, please go to extension settings (read README.md for more info)\"',\n      });\n      return;\n    }\n    \n    let chat_response = '';\n    let searchPrompt = \"\";\n    if (prompt!=undefined) {\n      searchPrompt = await this._generate_search_prompt(prompt);\n    } \n    // Show loading indicator\n    this._view?.webview.postMessage({ type: 'setPrompt', value: this._prompt });\n    this._view?.webview.postMessage({ type: 'addResponse', value: '...' });\n\n    if (searchPrompt != \"\") {\n      this._messages?.push({ role: \"user\", content: searchPrompt, selected:true })\n    }\n\n    if (!this._openai) {\n      throw new Error('OpenAI instance is not initialized.');\n    }\n    \n    if (typeof this._settings.model !== 'string') {\n      throw new Error('Model identifier is not valid or not defined.');\n    }\n\n    // Only if you can't change the Message interface\n    const isValidRole = (role: any): role is 'user' | 'assistant' | 'system' => {\n      return ['user', 'assistant', 'system'].includes(role);\n    };\n    \n    // Validate and type narrow `this._messages` before sending\n    if (!this._messages || !Array.isArray(this._messages) ||\n      (!this._messages.every(msg => isValidRole(msg.role)))) {\n      throw new Error('Messages have invalid roles.');\n    }\n\n    const promtNumberOfTokens = this._getMessagesNumberOfTokens();\n    let full_message = \"\";\n    try {\n      console.log(\"Creating message sender...\");\n      \n      let messagesToSend: Array<Message> = [];\n      \n      // Assuming this._messages is defined and is an array\n      for (const message of this._messages) {\n        // Check if 'selected' is true; undefined or false values will be considered false\n        if (message.selected) {\n          //if (messagesToSend.length > 0 && messagesToSend[messagesToSend.length - 1].role === message.role) {\n          //  // Append the content to the previous message if the role is the same\n          //  messagesToSend[messagesToSend.length - 1] = {\n          //\t...messagesToSend[messagesToSend.length - 1],\n          //\tcontent: messagesToSend[messagesToSend.length - 1].content + '\\n' + message.content,\n          //  };\n          //} else {\n            // Add the message as a new entry, omitting the 'selected' key\n            const { selected, ...messageWithoutSelected } = message; // Destructure and omit 'selected'\n            messagesToSend.push(messageWithoutSelected);\n          //}\n        }\n      }\n\n      const stream = await this._openai.chat.completions.create({\n        model: this._settings.model,\n        messages: messagesToSend,\n        stream: true,\n        ...this._settings.options, // Spread operator to include all keys from options\n      });\n      \n      console.log(\"Message sender created\");\n      \n      let completionTokens = 0;\n      full_message = \"\";\n      for await (const chunk of stream) {\n        const content = chunk.choices[0]?.delta?.content || \"\";\n        console.log(\"chunk:\",chunk);\n        console.log(\"content:\", content);\n        const tokenList = this._enc.encode(content);\n        completionTokens += tokenList.length;\n        console.log(\"tokens:\", completionTokens);\n        full_message += content;\n        //this._response = chat_response;\n        this._view?.webview.postMessage({ type: 'addResponse', value: full_message });\n\n      }\n      this._messages?.push({ role: \"assistant\", content: full_message, selected:true })\n      console.log(\"Full message:\", full_message);\n      console.log(\"Full Number of tokens:\", completionTokens);\n      const tokenList = this._enc.encode(full_message);\n      console.log(\"Full Number of tokens tiktoken:\", tokenList.length);\n      chat_response = this._updateChatMessages(promtNumberOfTokens, tokenList.length)\n    } catch (e: any) {\n      console.error(e);\n      if (this._response!=undefined) {\n        this._messages?.push({ role: \"assistant\", content: full_message, selected:true })\n        chat_response = this._response;\n        chat_response += `\\n\\n---\\n[ERROR] ${e}`;\n      }\n    }\n    this._response = chat_response;\n    this._view?.webview.postMessage({ type: 'addResponse', value: chat_response });\n    this._view?.webview.postMessage({ type: 'setPrompt', value: '' });\n  }\n\n  private _getHtmlForWebview(webview: vscode.Webview) {\n  \n    const scriptUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'main.js'));\n    const stylesUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'styles.css'));\n    const microlightUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'scripts', 'microlight.min.js'));\n    const tailwindUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'scripts', 'tailwind.min.js'));\n    const showdownUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'scripts', 'showdown.min.js'));\n  \n    return `<!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n      <meta charset=\"UTF-8\">\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n      <script src=\"${tailwindUri}\"></script>\n      <script src=\"${showdownUri}\"></script>\n      <script src=\"${microlightUri}\"></script>\n      <link rel=\"stylesheet\" href=\"${stylesUri}\">\n    </head>\n    <body>\n      <div id=\"container\">\n        <div id=\"top-wrapper\">\n          <label for=\"provider-selector\">Provider:</label>\n          <select id=\"provider-selector\"></select>\n          <label for=\"model-selector\">Model:</label>\n          <select id=\"model-selector\"></select>\n        </div>\n        <div id=\"response\" class=\"text-sm\"></div>\n        <div id=\"input-wrapper\">\n          <div>\n            <label for=\"system-prompt-selector\">System Prompt:</label>\n            <select id=\"system-prompt-selector\">\n            </select>\n          </div>\n          <input type=\"text\" id=\"prompt-input\" placeholder=\"Ask ChatGPT something\">\n        </div>\n      </div>\n      <script src=\"${scriptUri}\"></script>\n    </body>\n    </html>`;\n  }\n\n  public addImageToChat(imageDataUrl: string, fileName: string) {\n    const imageMarkdown = `![${fileName}](${imageDataUrl})`;\n    let newMessage: UserMessage = { \n      role: \"user\", \n      content: [\n        {\n          \"type\": \"text\",\n          \"text\": fileName + \":\"\n        },\n        {\n          \"type\": \"image_url\",\n          \"image_url\": {\n            \"url\": imageDataUrl\n          }\n        }\n      ], \n      selected: true\n    };\n\n    \n    this._messages?.push(newMessage);\n  \n    const chat_response = this._updateChatMessages(this._getMessagesNumberOfTokens(), 0);\n    this._view?.webview.postMessage({ type: 'addResponse', value: chat_response });\n  }\n\n  public addFileToChat(relativePath: string, fileContent: string, fileExtension: string) {\n    let codeBlock = `**${relativePath}**\\n\\`\\`\\`${fileExtension}\\n${fileContent}\\n\\`\\`\\``;\n  \n    let newMessage: UserMessage = {\n      role: \"user\",\n      content: codeBlock,\n      selected: true\n    };\n  \n    this._messages?.push(newMessage);\n  \n    const chat_response = this._updateChatMessages(this._getMessagesNumberOfTokens(), 0);\n    this._view?.webview.postMessage({ type: 'addResponse', value: chat_response });\n  }\n}\n```"
  selected: true
- role: user
  content: "**src/extension.ts**\n```ts\nimport * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { Provider, Prompt, ProviderSettings } from './types';\nimport { ChatGPTViewProvider } from './chatGptViewProvider';\n\n// Base URL for OpenAI API\nconst BASE_URL = 'https://api.openai.com/v1';\n\nexport function activate(context: vscode.ExtensionContext) {\n\tconsole.log('activating extension \"chatgpt\"');\n\t// Get the settings from the extension's configuration\n\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\n\t// Create a new ChatGPTViewProvider instance and register it with the extension's context\n\tconst provider = new ChatGPTViewProvider(context.extensionUri);\n\n\tlet providers: Provider[] = config.get('providers') || [];\n\tconsole.log(\"Providers:\", providers);\n\n\tlet prompts: Prompt[] = config.get('prompts') || [];\n\tconsole.log(\"prompts:\", prompts);\n\n\tlet activate_provider_settings: ProviderSettings = {\n\t  model: \"none\",\n\t  apiUrl: BASE_URL,\n\t  apiKey: \"none\",\n\t  options: {\n\t\tmaxModelTokens: 1000,\n\t\tmaxResponseTokens: 1000,\n\t\ttemperature: 1.0,\n\t  },\n\t};\n\n\tif (providers && providers.length > 0) {\n\t\tconst firstProvider = providers[0];\n\t\tif (firstProvider.models && firstProvider.models.length > 0) {\n\t\t\tconst firstModel = firstProvider.models[0];\n\t\t\t// Assuming firstModel and firstProvider are already defined based on your JSON structure:\n\t\t\tactivate_provider_settings = {\n\t\t\t  model: firstModel.name,\n\t\t\t  apiUrl: firstProvider.apiUrl,\n\t\t\t  apiKey: firstProvider.apiKey,\n\t\t\t  options: {\n\t\t\t\t...firstModel.options, // Spread operator to include all keys from options\n\t\t\t  },\n\t\t\t};\n\t\t}\n\t}\n\t\n\tprovider.setSettings({\n\t  selectedInsideCodeblock: config.get('selectedInsideCodeblock') || false,\n\t  codeblockWithLanguageId: config.get('codeblockWithLanguageId') || false,\n\t  pasteOnClick: config.get('pasteOnClick') || false,\n\t  keepConversation: config.get('keepConversation') || false,\n\t  timeoutLength: config.get('timeoutLength') || 60,\n\t  apiUrl: activate_provider_settings.apiUrl,\n\t  model: activate_provider_settings.model,\n\t  options: {\n\t\t...activate_provider_settings.options, // Use spread operator to include all options\n\t  },\n\t});\n\n\t// Put configuration settings into the provider\n\tprovider.setAuthenticationInfo({\n\t\tapiKey: activate_provider_settings.apiKey,\n\t\tapiUrl: activate_provider_settings.apiUrl\n\t});\n\t\n\t// Register the provider with the extension's context\n\tcontext.subscriptions.push(\n\t\tvscode.window.registerWebviewViewProvider(ChatGPTViewProvider.viewType, provider, {\n\t\t\twebviewOptions: { retainContextWhenHidden: true }\n\t\t})\n\t);\n\n\tcontext.subscriptions.push(\n\t  vscode.commands.registerCommand('chatgpt.addFileToChat', async (uri: vscode.Uri) => {\n\t\tif (!uri || !uri.fsPath) {\n\t\t  vscode.window.showErrorMessage('No file selected!');\n\t\t  return;\n\t\t}\n\t\ttry {\n\t\t  const fileContent = await fs.promises.readFile(uri.fsPath, 'utf8');\n\t\t  const workspaceFolder = vscode.workspace.getWorkspaceFolder(uri);\n\t\t  let relativePath: string;\n\t\n\t\t  if (workspaceFolder) {\n\t\t\trelativePath = path.relative(workspaceFolder.uri.fsPath, uri.fsPath);\n\t\t  } else {\n\t\t\trelativePath = path.basename(uri.fsPath);\n\t\t  }\n\t\t  let fileExtension = path.extname(relativePath).substring(1);\n\t\n\t\t  let codeBlock = `**${relativePath}**\\n\\`\\`\\`${fileExtension}\\n${fileContent}\\n\\`\\`\\``;\n\t\t  provider.addFileToChat(relativePath, fileContent, fileExtension);  // Adjust method if desired\n\t\t} catch (err) {\n\t\t  vscode.window.showErrorMessage(`Failed to read file: ${err}`);\n\t\t}\n\t  })\n\t);\n\n\tconst commandHandler = (command: string) => {\n\t\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\t\tconst prompt = config.get(command) as string;\n\t\tprovider.search(prompt);\n\t};\n\n\t// Register the commands that can be called from the extension's package.json\n\tcontext.subscriptions.push(\n\t\tvscode.commands.registerCommand('chatgpt.ask', () =>\n\t\t\tvscode.window.showInputBox({ prompt: 'What do you want to do?' })\n\t\t\t\t.then((value) => provider.search(value))\n\t\t),\n\t\tvscode.commands.registerCommand('chatgpt.explain', () => commandHandler('promptPrefix.explain')),\n\t\tvscode.commands.registerCommand('chatgpt.refactor', () => commandHandler('promptPrefix.refactor')),\n\t\tvscode.commands.registerCommand('chatgpt.optimize', () => commandHandler('promptPrefix.optimize')),\n\t\tvscode.commands.registerCommand('chatgpt.findProblems', () => commandHandler('promptPrefix.findProblems')),\n\t\tvscode.commands.registerCommand('chatgpt.documentation', () => commandHandler('promptPrefix.documentation')),\n\t\tvscode.commands.registerCommand('chatgpt.resetConversation', () => provider.resetConversation()),\n\t\tvscode.commands.registerCommand('chatgpt.pasteChat', () => provider.pasteChat()),\n\t\tvscode.commands.registerCommand('chatgpt.useSelectionAsChat', () => provider.useSelectionAsChat())\n\n\t\t\n\t);\n\n\n\t// Change the extension's session token or settings when configuration is changed\n\tvscode.workspace.onDidChangeConfiguration((event: vscode.ConfigurationChangeEvent) => {\n\t\tif (event.affectsConfiguration('chatgpt.providers')) {\n\t\t\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\t\t\tlet providers: Provider[] = config.get('providers') || [];\n\n\t\t\tif (providers && providers.length > 0) {\n\t\t\t\tconst firstProvider = providers[0];\n\t\t\t\tif (firstProvider.models && firstProvider.models.length > 0) {\n\t\t\t\t\tconst firstModel = firstProvider.models[0];\n\t\t\t\t\tactivate_provider_settings = {\n\t\t\t\t\t  model: firstModel.name,\n\t\t\t\t\t  apiUrl: firstProvider.apiUrl,\n\t\t\t\t\t  apiKey: firstProvider.apiKey,\n\t\t\t\t\t  options: {\n\t\t\t\t\t\t...firstModel.options, // Use spread operator to include all options\n\t\t\t\t\t  },\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tprovider.setSettings({\n\t\t\t\t  apiUrl: activate_provider_settings.apiUrl,\n\t\t\t\t  model: activate_provider_settings.model,\n\t\t\t\t  options: {\n\t\t\t\t\t...activate_provider_settings.options, // Use spread operator to include all options\n\t\t\t\t  },\n\t\t\t\t});\n\t\t\t\n\t\t\t\t// Put configuration settings into the provider\n\t\t\t\tprovider.setAuthenticationInfo({\n\t\t\t\t\tapiKey: activate_provider_settings.apiKey,\n\t\t\t\t\tapiUrl: activate_provider_settings.apiUrl\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tprovider.set_providers(providers);//Update the selectors\n\t\t\t}\n\t\t} else if (event.affectsConfiguration('chatgpt.prompts')) {\n\t\t\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\t\t\tlet prompts: Prompt[] = config.get('prompts') || [];\n\n\t\t\tif (prompts && prompts.length > 0) {\n\t\t\t\tconst firstPrompt = prompts[0];\n\t\t\t\tprovider.set_prompt(firstPrompt);\n\t\t\t}\n\t\t\tprovider.set_prompts(prompts);\n\t\t} else if (event.affectsConfiguration('chatgpt.selectedInsideCodeblock')) {\n\t\t\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\t\t\tprovider.setSettings({ selectedInsideCodeblock: config.get('selectedInsideCodeblock') || false });\n\t\t} else if (event.affectsConfiguration('chatgpt.codeblockWithLanguageId')) {\n\t\t\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\t\t\tprovider.setSettings({ codeblockWithLanguageId: config.get('codeblockWithLanguageId') || false });\n\t\t} else if (event.affectsConfiguration('chatgpt.pasteOnClick')) {\n\t\t\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\t\t\tprovider.setSettings({ pasteOnClick: config.get('pasteOnClick') || false });\n\t\t} else if (event.affectsConfiguration('chatgpt.keepConversation')) {\n\t\t\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\t\t\tprovider.setSettings({ keepConversation: config.get('keepConversation') || false });\n\t\t} else if (event.affectsConfiguration('chatgpt.timeoutLength')) {\n\t\t\tconst config = vscode.workspace.getConfiguration('chatgpt');\n\t\t\tprovider.setSettings({ timeoutLength: config.get('timeoutLength') || 60 });\n\t\t}\n\t});\n\n\n\tcontext.subscriptions.push(\n\t\tvscode.commands.registerCommand('chatgpt.addImageToChat', async (uri: vscode.Uri) => {\n\t\t  if (uri && uri.fsPath) {\n\t\t\tconst filePath = uri.fsPath;\n\t\t\tconst fileName = path.basename(filePath);\n\t\t\tconst fileData = await fs.promises.readFile(filePath, { encoding: 'base64' });\n\t\t\tconst fileType = path.extname(filePath).substring(1); // get file extension without dot\n\t\t\tconst imageDataUrl = `data:image/${fileType};base64,${fileData}`;\n\t\n\t\t\t// Post a message to the webview to add the image\n\t\t\tprovider.addImageToChat(imageDataUrl, fileName);\n\t\t  }\n\t\t})\n\t  );\n}\n\n// This method is called when your extension is deactivated\nexport function deactivate() { }\n```"
  selected: true
- role: user
  content: |-
    **src/types.ts**
    ```ts
    import { ChatCompletionAssistantMessageParam, ChatCompletionContentPart, ChatCompletionContentPartImage, ChatCompletionContentPartText, ChatCompletionSystemMessageParam, ChatCompletionUserMessageParam } from 'openai/resources/chat/completions';

    export type AuthInfo = { apiKey?: string, apiUrl?: string };

    export type Settings = {
      selectedInsideCodeblock?: boolean;
      codeblockWithLanguageId?: false;
      pasteOnClick?: boolean;
      keepConversation?: boolean;
      timeoutLength?: number;
      model?: string;
      apiUrl?: string;
      options?: {
        [key: string]: any; // Allows for any number of properties with any value type
      };
    };

    export interface Model {
      name: string;
      options: {
        [key: string]: any; // Allows the `options` object to have any string keys with any value types
      };
    }

    export interface Provider {
      name: string;
      apiKey: string;
      apiUrl: string;
      models: Model[];
    }

    export interface ProviderSettings {
      model: string;
      apiUrl: string;
      apiKey: string;
      options: {
        [key: string]: any; // This allows options to have any number of properties with any types
      };
    }

    export interface Prompt {
      name: string;
      prompt: string;
    }

    export interface SystemMessage extends ChatCompletionSystemMessageParam {
      selected?: boolean;  // Additional property specific to Message
    }

    export interface UserMessage extends ChatCompletionUserMessageParam {
      selected?: boolean;  // Additional property specific to Message
    }

    export interface AssistantMessage extends ChatCompletionAssistantMessageParam {
      selected?: boolean;  // Additional property specific to Message
    }

    export type Message =
      | SystemMessage
      | UserMessage
      | AssistantMessage

    export const BASE_URL = 'https://api.openai.com/v1';
    ```
  selected: true
- role: user
  content: "**README.md**\n```md\n# ChatGPT for Visual Studio Code: Write and Improve Code Using AI\n\nEnhance your development workflow by leveraging the power of ChatGPT (GPT-3.5, GPT-4, and more) directly within Visual Studio Code. Generate, explain, refactor, document, and troubleshoot your code with AI assistance, all without leaving your editor.\n\n![ChatGPT in VS Code](examples/main.png)\n\n---\n\n## 🚀 Features\n\n- **Multi-provider, multi-model support**: Configure multiple AI providers and easily switch between models (e.g., OpenAI or your custom endpoints).\n- **Interactive Chat Panel**: Dedicated ChatGPT side panel in the VS Code Activity Bar for ongoing conversations.\n- **Code Actions**:  \n\t- Ask ChatGPT any coding question.\n\t- Explain selected code.\n\t- Refactor code with explanations.\n\t- Detect and fix bugs in code.\n\t- Optimize code for performance and readability.\n\t- Generate documentation for code snippets.\n- **YAML Chat Export/Import**: Export your conversation as YAML, or import YAML conversations as sessions for reproducibility.\n- **File and Image Attachments**: Send source files or images to ChatGPT by right-clicking in the explorer.\n- **Custom System Prompts**: Define and select your own system prompts for specialized AI behaviors (reviewer, tutor, etc).\n- **Configuration Options**: Fine-tune how code is sent (inside code blocks, with language IDs), control streaming, timeouts, and more.\n- **Token Usage Tracking**: See token counts and usage for better understanding of API limits.\n\n---\n\n## 📦 Installation\n\n1. Install from the [Visual Studio Code Marketplace](https://marketplace.visualstudio.com/) (or manually download the `.vsix` from releases and install via VS Code).\n2. Open the **Command Palette** (`Ctrl+Shift+P`) and search for `ChatGPT: Ask`, or open the ChatGPT side panel from the Activity Bar.\n\n---\n\n## 🛠️ Usage Guide\n\n### Interacting with AI\n\n- **Chat Side Panel**: Access the ChatGPT panel from the activity bar, type your prompt, and interact with the conversation just like in a chat app.\n- **Context Menu Actions**:\n\t- Right-click code (or select code → right-click) for quick actions like *Explain*, *Refactor*, *Find Problems*, *Optimize*, or *Document*.\n\t- Attach a file or image by right-clicking it in the explorer and choosing “Add to ChatGPT”.\n\n### Export/Import Chat\n\n- Use `ChatGPT: Paste Chat` to export the chat as YAML in your editor.\n- Use `ChatGPT: Use Selection as Chat` to load a YAML conversation from the editor into your current chat session.\n\n![Explain Selection Example](examples/explain.png)\n![Refactor Example](examples/refactor.png)\n\n---\n\n## ⚙️ Configuration\n\nOpen **Settings** (`Ctrl+,` or `Cmd+,`) and search for `chatgpt` to find and configure options such as:\n\n<!-- Example table of key settings -->\n| Setting                     | Description                                                    |\n|-----------------------------|----------------------------------------------------------------|\n| chatgpt.providers           | List of AI providers, API keys, API URLs, and available models.|\n| chatgpt.prompts             | Your reusable system prompts for controlling AI “personality”. |\n| chatgpt.pasteOnClick        | Paste code from chat code blocks on click in the editor.        |\n| chatgpt.selectedInsideCodeblock | Send selected code as markdown codeblocks.                |\n| chatgpt.codeblockWithLanguageId | Append language for better formatting and syntax hints.   |\n| chatgpt.keepConversation    | Retain context across messages.                                |\n| chatgpt.timeoutLength       | Request timeout in seconds.                                    |\n\n### Example: Configuring Providers\n\n```jsonc\n\"chatgpt.providers\": [\n\t{\n\t\"name\": \"OpenAI\",\n\t\"apiKey\": \"your-openai-api-key\",\n\t\"apiUrl\": \"https://api.openai.com/v1\",\n\t\"models\": [\n\t\t{\n\t\t\"name\": \"gpt-3.5-turbo\",\n\t\t\"options\": {\n\t\t\t\"temperature\": 0.7\n\t\t}\n\t\t},\n\t\t{\n\t\t\"name\": \"gpt-4\",\n\t\t\"options\": {\n\t\t\t\"temperature\": 0.5\n\t\t}\n\t\t}\n\t]\n\t}\n]\n```\n\n### Example: Adding Custom System Prompts\n\n```jsonc\n\"chatgpt.prompts\": [\n\t{\n\t\"name\": \"Code Reviewer\",\n\t\"prompt\": \"You are a strict code reviewer. Explain suggestions thoroughly.\"\n\t},\n\t{\n\t\"name\": \"Simple Helper\",\n\t\"prompt\": \"You are a helpful but concise assistant.\"\n\t}\n]\n```\n\n---\n\n## 🔒 Privacy & Security\n\n- **Your API Keys**: You must supply your own OpenAI (or alternative) API keys. These are stored locally by VS Code and sent only to the API you select.\n- **No Data is Sent to Third Parties** except your configured providers.\n\n---\n\n## 🧩 Extending & Contributing\n\n### Building Locally\n\n1. Clone this repository.\n2. Install dependencies: `yarn install` or `npm install`\n3. Build the extension: `yarn compile` or `npm run compile`\n4. Launch in VS Code “Extension Development Host”.\n\n### Development Notes\n\n- Main code: [`src/extension.ts`](src/extension.ts), [`src/chatGptViewProvider.ts`](src/chatGptViewProvider.ts)\n- Webview UI: [`media/`](media/)\n- Configuration: [`package.json`](package.json)\n\nPRs and feature requests are welcome. See [CONTRIBUTING.md](CONTRIBUTING.md) (create if needed) for guidelines.\n\n---\n\n## 📝 License\n\nMIT License.  \nThis is an unofficial third-party integration. ChatGPT/OpenAI are trademarks of OpenAI, Inc.\n\n---\n\n## 🙋 Support & Feedback\n\nPlease open an [issue](https://github.com/timkmecl/chatgpt-vscode/issues) for bugs, support, or feature requests!\n\n---\n\nHappy coding!  \n— The ChatGPT for VS Code Team\n\n---\n\n*This project is not affiliated with or endorsed by OpenAI. Use responsibly.*\n\n---\n\n```"
  selected: true
- role: user
  content: "**webpack.config.js**\n```js\n//@ts-check\n\n'use strict';\n\nconst path = require('path');\n\n//@ts-check\n/** @typedef {import('webpack').Configuration} WebpackConfig **/\n\n/** @type WebpackConfig */\nconst extensionConfig = {\n  target: 'node', // VS Code extensions run in a Node.js-context 📖 -> https://webpack.js.org/configuration/node/\n\tmode: 'none', // this leaves the source code as close as possible to the original (when packaging we set this to 'production')\n\n  entry: './src/extension.ts', // the entry point of this extension, 📖 -> https://webpack.js.org/configuration/entry-context/\n  output: {\n    // the bundle is stored in the 'dist' folder (check package.json), 📖 -> https://webpack.js.org/configuration/output/\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'extension.js',\n    libraryTarget: 'commonjs2'\n  },\n  externals: {\n    'playwright-core': 'commonjs2 playwright-core',\n    vscode: 'commonjs vscode' // the vscode-module is created on-the-fly and must be excluded. Add other modules that cannot be webpack'ed, 📖 -> https://webpack.js.org/configuration/externals/\n    // modules added here also need to be added in the .vscodeignore file\n  },\n  resolve: {\n    // support reading TypeScript and JavaScript files, 📖 -> https://github.com/TypeStrong/ts-loader\n    extensions: ['.ts', '.js']\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        exclude: /node_modules/,\n        use: [\n          {\n            loader: 'ts-loader'\n          }\n        ]\n      }\n    ]\n  },\n  devtool: 'nosources-source-map',\n  infrastructureLogging: {\n    level: \"log\", // enables logging required for problem matchers\n  },\n};\nmodule.exports = [ extensionConfig ];\n```"
  selected: true
- role: user
  content: "tsconfig.json\n```jsonc\n{\n\t\"compilerOptions\": {\n\t\t\"module\": \"commonjs\",\n\t\t\"target\": \"ES2020\",\n\t\t\"lib\": [\n\t\t\t\"ES2020\"\n\t\t],\n\t\t\"sourceMap\": true,\n\t\t\"rootDir\": \"src\",\n\t\t\"strict\": true   /* enable all strict type-checking options */\n\t\t/* Additional Checks */\n\t\t// \"noImplicitReturns\": true, /* Report error when not all code paths in function return a value. */\n\t\t// \"noFallthroughCasesInSwitch\": true, /* Report errors for fallthrough cases in switch statement. */\n\t\t// \"noUnusedParameters\": true,  /* Report errors on unused parameters. */\n\t}\n}\n\n```"
  selected: true
- role: assistant
  content: |-
    Here is the generated `project_description_for_ai.md` file, based on the information you provided:

    ---

    # project_description_for_ai.md

    ## 1. Project Overview

    **ChatGPT for Visual Studio Code** is a Visual Studio Code extension that integrates OpenAI’s models (ChatGPT-3.5, GPT-4, and more) directly into the IDE. It provides users with interactive chat-based features to generate, explain, refactor, document, and troubleshoot code. The extension supports customizable AI providers, multiple models, system prompts, and enables users to send files or images for AI processing. Users interact with ChatGPT via a dedicated Activity Bar panel and context-menu actions, enhanced by features like YAML chat export/import, configurable settings, and token usage tracking.

    ---

    ## 2. Project Directory Tree

    ```
    .
    ├── CHANGELOG.md
    ├── diegoaacchatgpt-1.1.0.vsix
    ├── dist/
    │   ├── extension.js
    │   ├── extension.js.LICENSE.txt
    │   └── extension.js.map
    ├── examples/
    │   ├── create.png
    │   ├── explain.png
    │   ├── main.png
    │   └── refactor.png
    ├── media/
    │   ├── main.js
    │   ├── scripts/
    │   │   ├── microlight.min.js
    │   │   ├── showdown.min.js
    │   │   └── tailwind.min.js
    │   └── styles.css
    ├── package-lock.json
    ├── package.json
    ├── README.md
    ├── resources/
    │   ├── buy-default-yellow-small.png
    │   ├── extensionIcon.png
    │   └── icon.png
    ├── src/
    │   ├── chatGptViewProvider.ts
    │   ├── extension.ts
    │   └── types.ts
    ├── toGenerateXSIX.txt
    ├── tsconfig.json
    ├── vsc-extension-quickstart.md
    ├── webpack.config.js
    └── yarn.lock
    ```

    ---

    ## 3. File-by-File Explanation

    ### Project Root

    - **package.json**  
      Defines VS Code extension metadata, activation events, contributions (commands, menus, settings), scripts, dependencies, and configuration schemas for providers/models/prompts.

    - **README.md**  
      User guide, feature overview, usage instructions, configuration reference, privacy notes, and contribution guidelines.

    - **webpack.config.js**  
      Webpack bundling configuration for extension code, outputs to `dist/`.

    - **tsconfig.json**  
      TypeScript compiler configuration with commonjs modules, ES2020 targeting, source maps, and strict type checks.

    ### `/src`

    - **extension.ts**  
      Main activation script for the extension. Registers commands, listens for configuration changes, loads provider/model info, and connects UI logic (via `ChatGPTViewProvider`). Handles context menu and command palette actions.

    - **chatGptViewProvider.ts**  
      Implements the chat panel’s backend (`WebviewViewProvider`). Manages message state, user/session prompts, token tracking, and all core interactions between the extension and the OpenAI API (including streaming, file/image support, chat YAML import/export, and configuration).

    - **types.ts**  
      Defines core TypeScript types and interfaces: provider, model, message, settings, authentication info. Imports message types from the OpenAI SDK for type safety.

    ### `/dist`

    - **extension.js**  
      Webpack-built JS bundle from TypeScript, actual entry point specified in `package.json`.

    ### `/media`

    - **main.js**  
      Handles the dynamic webview UI in the ChatGPT VS Code panel.

    - **scripts/**  
      Minified JS libraries for Markdown rendering, syntax highlighting, TailwindCSS.

    - **styles.css**  
      UI styling for the ChatGPT webview.

    ### `/examples`

    - **main.png**, **explain.png**, **refactor.png**, **create.png**  
      Usage screenshots referenced in the README.

    ### `/resources`

    - **extensionIcon.png**, **icon.png**, **buy-default-yellow-small.png**  
      Extension and activity bar icons.

    ---

    ## 4. Important Design Notes for Modification

    - **Provider/Model Extensibility:**  
      - Providers and models are defined in the user/workspace settings (see `package.json` configuration schema and README). Adding support for new AI providers involves expanding the configuration input/output logic in `chatGptViewProvider.ts`.
      - The extension expects providers to use the OpenAI-compatible API; custom endpoints need similar semantics.

    - **Prompt & System Prompt Handling:**  
      - Prompts can be customized/selected by users. The `chatGptViewProvider.ts` handles loading and updating system prompts dynamically.

    - **UI & Webview:**  
      - Frontend JS (`media/main.js`) and CSS (`media/styles.css`) can be modified for more UI features in the chat panel.  
      - The backend (TypeScript) posts messages to the webview and responds to user actions (command invocations, chat input, checkbox state, etc.).

    - **Commands & Menus:**  
      - Extension commands (ask, explain, refactor, etc.) are registered in `src/extension.ts` and mapped in `package.json`.

    - **YAML Chat Export/Import:**  
      - Allows session portability and reproducibility by serializing/deserializing message history.

    - **Token Counting:**  
      - Uses `js-tiktoken` for model-specific token estimation.

    - **Adding File/Image Context:**  
      - Handler functions allow users to send file contents or images to the chat as context/messages.

    ---

    ## 5. Security Considerations

    - **API Keys:**  
      - API keys for providers are user-supplied and read from workspace settings. They are not transmitted to third parties except the configured API URL.
      - Keys are not sent in analytics or telemetry.

    - **Webview Security:**  
      - Webview allows scripts, so sanitization of any user-generated content should be considered if extended.
      - Only resources within the extension’s installation are permitted for `localResourceRoots`.

    - **External Endpoints:**  
      - API URLs are user-configurable; extension trusts them fully. Advise users to ensure only endpoints they control/trust are configured.

    - **File/Image Attachments:**  
      - File and image content are read and sent to the provider API. No third-party leaks except to the provider endpoint.

    - **Streaming & Async Operations:**  
      - Handles streaming responses securely; errors are posted to the webview.

    - **No storage of chat history** beyond session memory; export/import is user-initiated.

    ---

    ## 6. Summary Table of Main Extensible or Important Areas

    | Area                        | File(s)                         | Extensible/Key APIs      | Description                                        |
    |-----------------------------|---------------------------------|--------------------------|----------------------------------------------------|
    | Providers/Models            | package.json, types.ts          | User settings schema     | Add/modify AI providers and their models           |
    | Core Chat View/Logic        | src/chatGptViewProvider.ts      | `ChatGPTViewProvider`    | Chat state, message handling, UI backend           |
    | Commands/Actions            | package.json, src/extension.ts  | Command registry         | Editor/Panel actions, context menu, code actions   |
    | Webview UI                  | media/main.js, styles.css       | WebviewViewProvider API  | Chat panel frontend, interactivity                 |
    | Prompts & System Prompts    | package.json, types.ts          | Prompts configuration    | Custom/Selectable AI "personalities"               |
    | File/Image Context Support  | src/chatGptViewProvider.ts      | addFileToChat, addImageToChat | Attach files/images to conversation        |
    | Token Counting & Limits     | js-tiktoken, src/chatGptViewProvider.ts | encodingForModel() | Tracks/limits token usage for requests             |
    | YAML Export/Import          | src/chatGptViewProvider.ts      | pasteChat, useSelectionAsChat | Session portability (YAML serialization)     |
    | VS Code Integration         | package.json, extension.ts      | Activation events, context | UI/UX embedding in VS Code                    |

    ---

    ## 7. Final Notes

    - The project is highly customizable and modular, built for extension and multi-provider interoperability.
    - Key extension points: provider/model schemas, custom prompt logic, webview UI updates, and new command integrations.
    - User input (API keys, endpoints, prompts) is trusted—input validation or further restrictions recommended for production use if targeting a wider audience.
    - The codebase is TypeScript-strict, leveraging OpenAI SDK types for safety.
    - Project already supports most standard ChatGPT extension requests (chat, context files, multi-prompt, streaming).
    - For further modification: focus on `chatGptViewProvider.ts` for chat logic, `extension.ts` for VS Code wiring, and `/media` for frontend.
    - Test workflow: `yarn install` + `yarn compile` + launch in Extension Development Host of VS Code.

    ---

    *For further technical reference, see in-code comments, the configuration schema in `package.json`, and the detailed README for end-user/customizer guidance.*
  selected: true
