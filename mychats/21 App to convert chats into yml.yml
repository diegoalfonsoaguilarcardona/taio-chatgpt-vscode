- role: system
  content: You are a helpfull assistant. Remember to diferenciate the codes with Triple backticks.
  selected: true
- role: user
  content: |-
    File reference: `package.json`
    <!--FILE:package.json-->
  selected: true
- role: user
  content: |-
    File reference: `src/chatGptViewProvider.ts`
    <!--FILE:src/chatGptViewProvider.ts-->
  selected: true
- role: user
  content: |-
    File reference: `src/extension.ts`
    <!--FILE:src/extension.ts-->
  selected: true
- role: user
  content: |-
    File reference: `src/types.ts`
    <!--FILE:src/types.ts-->
  selected: true
- role: user
  content: |-
    File reference: `media/main.js`
    <!--FILE:media/main.js-->
  selected: true
- role: user
  content: |-
    File reference: `media/styles.css`
    <!--FILE:media/styles.css-->
  selected: true
- role: user
  content: |-
    Okay, so I have this Visual Studio Code extension and this is an extension that allows me to talk with different providers, LLM providers, and in that way I can provide source and things like that and ask for modifications, I don't know, whatever I need to do with my source. There is only one thing, and it's that sometimes I have conversations in other places, for example in ChatGPT, and I want to be able to convert those conversations or some specific text into chat that I can then continue or maybe modify some parts or things like that. So I want you to create a new folder on this project, let's call it Applications, and inside that I want you to create just a simple HTML file, that HTML file is going to be a file that allows me to provide a text, a role, what I mean is, if it is a user or if it is an assistant, and then I want to create, hit a button append, and I can append that new text as if it was an assistant or if it was a user. So, I'm adding an example of a text that is the output of this, of what I want. So, for example, if I select user and I put the text, do you want, or do you know what is the difference, blah, blah, blah, it should add this as role, user, content, the text I provide you and select it through, and that should be appended to the output text. Then if I select assistant and I provide some text, for example, yes, there are two different OpenAI endpoints, blah, blah, blah, blah, what I want is, and then I hit append or click append, the application should append that role, assistant, content, and yes, there are two different, blah, blah, blah, everything should be appended. See that when I have multiple lines, that symbol after content is included, that is from the jam that is being created. I provide you with all the source code so you understand the format that I'm talking about because that is the format that I use when I paste the chat into a text file, and also I can select that text file and I can add or create the chat or use that text as the chat, so that is why I want to have that. So in conclusion, what I want is to have a way to select the role, remember that also there is a system role, so system, user, and assistant, and then I want a text field where I can put the text that I want to include, and a button to append whatever I want, and also an output text field where I have all the output, and remember when you append you are going to be appending more and more parts of the chat, and that's all that I want to do in that HTML file.
    ```yaml
    - role: user
      content: Do you know what is the difference between the responses api and the chat completions api (from openai)?
      selected: true
    - role: assistant
      content: |-
        Yes. They’re two different OpenAI endpoints with overlapping functionality but different goals and capabilities.

        High level
        - Chat Completions API
          - Legacy/chat-focused endpoint (messages array with roles: system/user/assistant).
          - Great for text-only chat and simple streaming.
          - Widely supported, stable, lots of existing tooling and examples.
          - Limited to the chat schema; multimodal support is partial and model-dependent.
      selected: true

    ```
  selected: true
- role: assistant
  content: |-
    Here’s a simple standalone builder you can drop into Applications/chat-builder.html. It lets you pick a role (system/user/assistant), type or paste multi-line content, and append entries to a YAML chat array that matches your extension’s format (including content: |- for multi-line). You can also copy the YAML or clear it.

    ```html
    <!-- Applications/chat-builder.html -->
    <!doctype html>
    <html lang="en">
    <head>
      <meta charset="utf-8">
      <title>Chat YAML Builder</title>
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        :root { color-scheme: light dark; }
        body { margin: 0; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
        .wrap { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; padding: 16px; }
        @media (max-width: 900px) { .wrap { grid-template-columns: 1fr; } }
        h1 { margin: 0 0 12px; font-size: 16px; }
        label { font-weight: 600; display: block; margin: 8px 0 6px; }
        select, textarea, input, button {
          font: inherit; padding: 8px; border-radius: 6px; border: 1px solid #8a8a8a40; width: 100%;
          background: canvas; color: canvastext;
        }
        textarea { min-height: 180px; resize: vertical; }
        .controls .row { display: grid; grid-template-columns: 180px 1fr; gap: 12px; align-items: center; }
        .buttons { display: flex; gap: 8px; margin-top: 10px; }
        button { width: auto; cursor: pointer; }
        .output textarea { min-height: 420px; white-space: pre; }
        .hint { color: #888; font-size: 12px; margin-top: 4px; }
      </style>
    </head>
    <body>
      <div class="wrap">
        <section class="controls">
          <h1>Compose Message</h1>
          <div class="row">
            <div>
              <label for="role">Role</label>
              <select id="role">
                <option value="system">system</option>
                <option value="user" selected>user</option>
                <option value="assistant">assistant</option>
              </select>
            </div>
            <div>
              <label for="content">Content</label>
              <textarea id="content" placeholder="Type or paste message content here..."></textarea>
              <div class="hint">Tip: Press Ctrl/Cmd + Enter to append.</div>
            </div>
          </div>
          <div class="buttons">
            <button id="append">Append</button>
            <button id="copy">Copy YAML</button>
            <button id="clear" title="Clear all">Clear</button>
          </div>
        </section>

        <section class="output">
          <h1>YAML Output</h1>
          <textarea id="output" readonly placeholder="- role: user
      content: |-
        Example multi-line
        content goes here
      selected: true"></textarea>
          <div class="hint">Paste this YAML into a file and use your extension’s “Use selection as Chat”.</div>
        </section>
      </div>

      <script>
        const entries = [];

        function toYamlString(str) {
          // Use JSON-style double-quoted string; valid YAML 1.2.
          return JSON.stringify(str);
        }

        function toYaml(entries) {
          const out = [];
          for (const e of entries) {
            out.push(`- role: ${e.role}`);
            const hasNewlines = e.content.includes('\n');
            if (hasNewlines) {
              out.push(`  content: |-`);
              const lines = e.content.replace(/\r\n/g, '\n').split('\n');
              for (const line of lines) out.push(`    ${line}`);
            } else {
              out.push(`  content: ${toYamlString(e.content)}`);
            }
            out.push(`  selected: true`);
          }
          return out.join('\n');
        }

        function render() {
          document.getElementById('output').value = toYaml(entries);
        }

        document.getElementById('append').addEventListener('click', () => {
          const role = document.getElementById('role').value;
          const content = document.getElementById('content').value || '';
          entries.push({ role, content });
          document.getElementById('content').value = '';
          render();
          document.getElementById('content').focus();
        });

        document.getElementById('copy').addEventListener('click', async () => {
          const out = document.getElementById('output');
          out.select();
          try {
            await navigator.clipboard.writeText(out.value);
          } catch {
            document.execCommand('copy');
          }
        });

        document.getElementById('clear').addEventListener('click', () => {
          entries.length = 0;
          render();
        });

        document.getElementById('content').addEventListener('keydown', (e) => {
          if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
            e.preventDefault();
            document.getElementById('append').click();
          }
        });
      </script>
    </body>
    </html>
    ```
  selected: true
- role: user
  content: 'Perfect, but I want to be able to paste what I have in the clipboard, so let''s add some buttons: one button that says "paste user message", other that says "paste assistant message" and other that says "paste code block" (in this the idea is that it should only paste code block with ``` (no role)) also add a one line text field where the user can provide the type of code block (for example "html" should be ```html).'
  selected: true
- role: assistant
  content: |-
    Great idea. Here’s an updated standalone builder that includes:
    - Paste user message
    - Paste assistant message
    - Paste code block (wraps clipboard text as a fenced block with a language you specify, but does not append until you click Append, so it has “no role” at paste time as requested)

    Drop this file at Applications/chat-builder.html.

    ```html
    <!-- Applications/chat-builder.html -->
    <!doctype html>
    <html lang="en">
    <head>
      <meta charset="utf-8">
      <title>Chat YAML Builder</title>
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        :root { color-scheme: light dark; }
        body { margin: 0; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
        .wrap { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; padding: 16px; }
        @media (max-width: 900px) { .wrap { grid-template-columns: 1fr; } }
        h1 { margin: 0 0 12px; font-size: 16px; }
        label { font-weight: 600; display: block; margin: 8px 0 6px; }
        select, textarea, input, button {
          font: inherit; padding: 8px; border-radius: 6px; border: 1px solid #8a8a8a40; width: 100%;
          background: canvas; color: canvastext;
        }
        textarea { min-height: 180px; resize: vertical; }
        .grid-2 { display: grid; grid-template-columns: 180px 1fr; gap: 12px; align-items: start; }
        .buttons { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; }
        button { width: auto; cursor: pointer; }
        .output textarea { min-height: 420px; white-space: pre; }
        .hint { color: #888; font-size: 12px; margin-top: 4px; }
        .row { display: grid; gap: 8px; }
        .inline { display: flex; gap: 8px; align-items: center; }
        .inline input[type="text"] { width: 180px; }
      </style>
    </head>
    <body>
      <div class="wrap">
        <section class="controls">
          <h1>Compose Message</h1>

          <div class="row grid-2">
            <div>
              <label for="role">Role</label>
              <select id="role">
                <option value="system">system</option>
                <option value="user" selected>user</option>
                <option value="assistant">assistant</option>
              </select>
            </div>
            <div>
              <label for="content">Content</label>
              <textarea id="content" placeholder="Type or paste message content here..."></textarea>
              <div class="hint">Tip: Press Ctrl/Cmd + Enter to append.</div>
            </div>
          </div>

          <div class="buttons">
            <button id="append">Append</button>
            <button id="copy">Copy YAML</button>
            <button id="clear" title="Clear all">Clear</button>
          </div>

          <h1 style="margin-top:16px">Quick Paste</h1>
          <div class="buttons">
            <button id="paste-user">Paste user message</button>
            <button id="paste-assistant">Paste assistant message</button>
          </div>
          <div class="inline" style="margin-top:8px">
            <label for="code-lang" style="margin:0; font-weight:600;">Code block lang</label>
            <input id="code-lang" type="text" placeholder="e.g., html, js, py" />
            <button id="paste-code">Paste code block</button>
          </div>
          <div class="hint">“Paste code block” inserts a fenced block into the Content field only (no role). You can then click Append with any role you want.</div>
        </section>

        <section class="output">
          <h1>YAML Output</h1>
          <textarea id="output" readonly placeholder="- role: user
      content: |-
        Example multi-line
        content goes here
      selected: true"></textarea>
          <div class="hint">Paste this YAML into a file and use your extension’s “Use selection as Chat”.</div>
        </section>
      </div>

      <script>
        const entries = [];

        function toYamlString(str) {
          // Use JSON-style double-quoted string; valid YAML 1.2 and safe for single-line content.
          return JSON.stringify(str);
        }

        function toYaml(entries) {
          const out = [];
          for (const e of entries) {
            out.push(`- role: ${e.role}`);
            const content = e.content ?? '';
            const hasNewlines = content.includes('\n');
            if (hasNewlines) {
              out.push(`  content: |-`);
              const lines = content.replace(/\r\n/g, '\n').split('\n');
              for (const line of lines) out.push(`    ${line}`);
            } else {
              out.push(`  content: ${toYamlString(content)}`);
            }
            out.push(`  selected: true`);
          }
          return out.join('\n');
        }

        function render() {
          document.getElementById('output').value = toYaml(entries);
        }

        function appendEntry(role, content) {
          entries.push({ role, content: content ?? '' });
          render();
        }

        function normalizeText(t) {
          return (t ?? '').replace(/\r\n/g, '\n');
        }

        async function readClipboardText() {
          try {
            const t = await navigator.clipboard.readText();
            return t ?? '';
          } catch (e) {
            // Fallback for older browsers—may not work in all contexts.
            try {
              const ta = document.createElement('textarea');
              document.body.appendChild(ta);
              ta.focus();
              document.execCommand('paste');
              const v = ta.value;
              document.body.removeChild(ta);
              return v || '';
            } catch {
              alert('Unable to read clipboard. Please paste manually.');
              return '';
            }
          }
        }

        // UI bindings
        document.getElementById('append').addEventListener('click', () => {
          const role = document.getElementById('role').value;
          const content = document.getElementById('content').value || '';
          appendEntry(role, content);
          document.getElementById('content').value = '';
          document.getElementById('content').focus();
        });

        document.getElementById('copy').addEventListener('click', async () => {
          const out = document.getElementById('output');
          out.select();
          try {
            await navigator.clipboard.writeText(out.value);
          } catch {
            document.execCommand('copy');
          }
        });

        document.getElementById('clear').addEventListener('click', () => {
          entries.length = 0;
          render();
        });

        document.getElementById('content').addEventListener('keydown', (e) => {
          if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
            e.preventDefault();
            document.getElementById('append').click();
          }
        });

        // Quick paste: user
        document.getElementById('paste-user').addEventListener('click', async () => {
          const txt = normalizeText(await readClipboardText());
          if (!txt) return;
          appendEntry('user', txt);
        });

        // Quick paste: assistant
        document.getElementById('paste-assistant').addEventListener('click', async () => {
          const txt = normalizeText(await readClipboardText());
          if (!txt) return;
          appendEntry('assistant', txt);
        });

        // Quick paste: code block (into content field only, no role)
        document.getElementById('paste-code').addEventListener('click', async () => {
          const lang = (document.getElementById('code-lang').value || '').trim();
          const txt = normalizeText(await readClipboardText());
          if (!txt) return;
          const fenced = '```' + lang + '\n' + txt + '\n```';
          const contentEl = document.getElementById('content');
          // Replace current content with the fenced block (or append if you prefer)
          contentEl.value = fenced;
          contentEl.focus();
          contentEl.setSelectionRange(fenced.length, fenced.length);
        });

        // Initial render
        render();
      </script>
    </body>
    </html>
    ```
  selected: true
